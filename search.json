[{"title":"如何做好职业生涯规划","url":"/posts/60194.html","content":"<p><span style=\"color:red;font-size:xx-large;\"><strong>让你的人生充满喜悦！</strong></span></p>\n<h2 id=\"一、职业生涯规划的意义\"><a href=\"#一、职业生涯规划的意义\" class=\"headerlink\" title=\"一、职业生涯规划的意义\"></a>一、职业生涯规划的意义</h2><ul>\n<li><p>以既有的成就为基础，确立人生的方向，提供奋斗的策略。 </p>\n</li>\n<li><p>突破生活的格线，塑造清新充实的自我。</p>\n</li>\n<li><p>准确评价个人特点和强项。</p>\n</li>\n<li><p>评估个人目标和现状的差距。</p>\n</li>\n<li><p>准确定位职业方向。</p>\n</li>\n<li><p>重新认识自身的价值并使其增值。</p>\n</li>\n<li><p>发现新的职业机遇。</p>\n</li>\n<li><p>增强职业竞争力。 </p>\n</li>\n<li><p>将个人、事业与家庭联系起来。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"二、正确的心理认知\"><a href=\"#二、正确的心理认知\" class=\"headerlink\" title=\"二、正确的心理认知\"></a>二、正确的心理认知</h2><h3 id=\"1、认清人生的价值\"><a href=\"#1、认清人生的价值\" class=\"headerlink\" title=\"1、认清人生的价值\"></a>1、认清人生的价值</h3><p>社会的价值并不被所有的人等同接受</p>\n<p> “人云亦云”并不等于自我的人生价值</p>\n<p>人生价值包括：经济价值、权力价值、回馈价值、审美价值、理论价值。</p>\n<h3 id=\"2、超越既有的得失\"><a href=\"#2、超越既有的得失\" class=\"headerlink\" title=\"2、超越既有的得失\"></a>2、超越既有的得失</h3><p>每个人都很努力，但成就并不等同。 </p>\n<p>后悔与抱怨对未来无济于事，自我陶醉则像“龟兔赛跑”中的兔子。 </p>\n<p>人生如运动场上的竞技，当下难以断输赢。</p>\n<h3 id=\"3、以万变应万变\"><a href=\"#3、以万变应万变\" class=\"headerlink\" title=\"3、以万变应万变\"></a>3、以万变应万变</h3><p>任何的执着都是一种“阻滞”前途的行为</p>\n<p>想想“流水”的启示</p>\n<p>“学非所用”是真理</p>\n<h2 id=\"三、剖析自我的现状\"><a href=\"#三、剖析自我的现状\" class=\"headerlink\" title=\"三、剖析自我的现状\"></a>三、剖析自我的现状</h2><h3 id=\"1、个人部份\"><a href=\"#1、个人部份\" class=\"headerlink\" title=\"1、个人部份\"></a>1、个人部份</h3><p><strong>健康情形：</strong> 身体是否有病痛？是否有不良的生活习惯？是否有影响健康的活动？生活是否正常？有没有养生之道？</p>\n<p><strong>自我充实：</strong> 是否有专长？经常阅读和收集资料吗？是否正在培养其他技能？</p>\n<p><strong>休闲管理：</strong> 是否有固定的休闲活动？有助于身心和工作吗？是否有休闲计划？</p>\n<h3 id=\"2、事业部份\"><a href=\"#2、事业部份\" class=\"headerlink\" title=\"2、事业部份\"></a>2、事业部份</h3><p><strong>财富所得：</strong> 薪资多少？有储蓄吗？有动产、有价证券吗？有不动产吗？价值多少？有外快吗？</p>\n<p><strong>社会阶层：</strong> 现在的职位是什么？还有升迁的机会吗？是否有升迁的准备呢？内外在的人际关系如何？</p>\n<p><strong>自我实现：</strong> 喜欢现在的工作吗？理由是什么？有完成人生理想的准备吗？</p>\n<h3 id=\"3、家庭部份\"><a href=\"#3、家庭部份\" class=\"headerlink\" title=\"3、家庭部份\"></a>3、家庭部份</h3><p><strong>生活品质：</strong> 居家环境如何？有没有计划换房子？家庭的布置和设备如何？有心灵或精神文化的生活吗？小孩、夫妻、父母有学习计划吗？</p>\n<p><strong>家庭关系：</strong> 夫妻和谐吗？是否拥有共同的发展目标？是否有共同或个别的创业计划？父母子女与父母、与公婆、与姑叔、与岳家的关系如何？是否常与家人相处、沟通、活动、旅游？</p>\n<p><strong>家人健康：</strong> 家里有小孩吗？小孩多大？健康吗？需要托人照顾吗？配偶的健康如何？家里有老人吗？有需要你照顾的家人吗？</p>\n<h2 id=\"四、人生发展的环境条件\"><a href=\"#四、人生发展的环境条件\" class=\"headerlink\" title=\"四、人生发展的环境条件\"></a>四、人生发展的环境条件</h2><ol>\n<li><strong>友伴条件：</strong> 朋友要多量化、多样化、且有能力。</li>\n<li><strong>生存条件：</strong> 要有储蓄、发展基金、不动产。</li>\n<li><strong>配偶条件：</strong> 个性要相投、社会态度要相同、要有共同的家庭目标。</li>\n<li><strong>行业条件：</strong> 注意社会当前及未来需要的行业，注意市场占有率。</li>\n<li><strong>企业条件：</strong> 要稳定，则在大中型企业；要创业，则在小企业。公司有改革计划吗？公司需要什么人才？</li>\n<li><strong>地区条件：</strong> 视行业和企业而定。</li>\n<li><strong>国家（社会）条件：</strong> 注意政治、法律、经济（资源、品质）、社会与文化、教育等条件，该社会的特性及潜在的市场条件。</li>\n<li><strong>世界条件：</strong> 注意全球正在发展的行业，用“世界观”发展事业。</li>\n</ol>\n<h2 id=\"五、人生成就的三大资源\"><a href=\"#五、人生成就的三大资源\" class=\"headerlink\" title=\"五、人生成就的三大资源\"></a>五、人生成就的三大资源</h2><ol>\n<li><p><strong>人脉：</strong> 家族关系、姻亲关系、同事（同学）关系、社会关系。</p>\n<p><strong>[解决方案]沟通与自我推销</strong></p>\n</li>\n<li><p><strong>金脉：</strong> 薪资所得、有价证券、基金、外币、定期存款、财产（动产、不动产）、信用（与为人和职位有关）。</p>\n<p><strong>[解决方案]储蓄、理财有方、夫妻合作、努力工作提高自己的能力条件及职位。</strong></p>\n</li>\n<li><p><strong>知脉：</strong> 知识力、技术力、咨讯力、企划力、预测（洞察）力、敏锐力。</p>\n<p><strong>[解决方案]做好时间管理、安排学习计划、上课、听讲座、进修、组织内轮调、多做事、反复练习、经常做笔记、做模拟计划。</strong></p>\n</li>\n</ol>\n<h2 id=\"六、组织内部发展生涯的途径\"><a href=\"#六、组织内部发展生涯的途径\" class=\"headerlink\" title=\"六、组织内部发展生涯的途径\"></a>六、组织内部发展生涯的途径</h2><h3 id=\"1、生涯甜筒取向\"><a href=\"#1、生涯甜筒取向\" class=\"headerlink\" title=\"1、生涯甜筒取向\"></a>1、生涯甜筒取向</h3><p>1）向内的</p>\n<p>2）垂直的</p>\n<p>3）水平的</p>\n<p><strong>[图表一]</strong> 生涯甜筒： 一个组织的三向度模式</p>\n<p><img src=\"http://assets.msyy233.com/20210310/1408458ff.png!blog\" alt=\"生涯甜筒\"></p>\n<h3 id=\"2、生涯角色取向\"><a href=\"#2、生涯角色取向\" class=\"headerlink\" title=\"2、生涯角色取向\"></a>2、生涯角色取向</h3><p>1）个人生涯可能承担的专业角色与生涯发展的七阶段</p>\n<p><img src=\"http://assets.msyy233.com/20210310/1409190a1.png!blog\" alt=\"角色主要任务重大心理议题\"></p>\n<h3 id=\"3、主要职能的开发\"><a href=\"#3、主要职能的开发\" class=\"headerlink\" title=\"3、主要职能的开发\"></a>3、主要职能的开发</h3><p>1）管理人员能力的培养 </p>\n<p>（1）各阶层管理人员必备的素质 </p>\n<p><img src=\"http://assets.msyy233.com/20210310/141129387.png!blog\" alt=\"各阶层管理人员必备的重要资质\"> </p>\n<p>（2）管理能力的结构与学习</p>\n<p><img src=\"http://assets.msyy233.com/20210310/141129d55.png!blog\" alt=\"管理能力的结构\"> </p>\n<p>（3）专门职（技术专才）职能的开发 </p>\n<p>（a）专门知识与广博知识 </p>\n<p> <img src=\"http://assets.msyy233.com/20210310/141129996.png!blog\" alt=\"研究技术人员的知识结构\"> </p>\n<p>（b）有效的专门能力开发方法 </p>\n<p> <img src=\"http://assets.msyy233.com/20210310/14112888f.png!blog\" alt=\"有效的专门能力的开发方法\"> </p>\n<h3 id=\"4、如何晋升高阶\"><a href=\"#4、如何晋升高阶\" class=\"headerlink\" title=\"4、如何晋升高阶\"></a>4、如何晋升高阶</h3><p>1）始终追随胜利者工作</p>\n<p>2）对公司要忠诚，但如果过度的忠诚会危害你的前途，也不妨考虑“骑驴找马”，另找明主。</p>\n<p>3）能够如何调和公司整体的利益与员工个人的需求；懂得毅然去做可能不受同事欢迎的决策。</p>\n<p>4）如果上述这种决策使某些人受到伤害，要与受害者沟通你的理由。</p>\n<p>5）延揽优秀的人才来弥补你在专业知识及技术上的不足。</p>\n<p>6）了解其他高级主管的优点及缺点。</p>\n<p>7）力求发挥所长，使公司获益。</p>\n<h3 id=\"5、更换工作的时机\"><a href=\"#5、更换工作的时机\" class=\"headerlink\" title=\"5、更换工作的时机\"></a>5、更换工作的时机</h3><p>1）如果你在一家公司太早就晋升至高阶，欲更上层楼，则需等待很久的时间。</p>\n<p>2）由于你最近的成功表现，使你的身价大幅提高时。</p>\n<p>3）如果你觉得你在现职上并未获得充分重视时。</p>\n<p>4）如果你的公司在竞争中落后，而你又无力促使公司迎头赶上时。</p>\n<p>5）如果公司的改组或变动使你的前程计划受到阻碍时。</p>\n<p>6）如果你又更高的眼界和新的理想时。</p>\n<p><strong>更换工作需要当机里断，不要犹豫不决，宁可冒点风险早作改变，也比踌躇不定好，以免错失良机</strong></p>\n<h3 id=\"6、如何管理职位与前程\"><a href=\"#6、如何管理职位与前程\" class=\"headerlink\" title=\"6、如何管理职位与前程\"></a>6、如何管理职位与前程</h3><p>1）对自己的雄心、长处及短处有实际的了解。</p>\n<p>2）不要好高务远。</p>\n<p>3）尽早规划自己的前程发展计划。</p>\n<p>4）谨言慎行，不要随便对别人推心置腹。</p>\n<p>5）小心维护自己的名誉。</p>\n<p>6）多了解组织中政治手段的运作情形。</p>\n<p>7）建立个人的情报网，消息要灵通。</p>\n<p>8）与现在担任你想要争取的职位的人士保持良好的关系。</p>\n<p>9）参加相关的专业社团或联谊组织。</p>\n<p>10）建立适当的形象。</p>\n<h2 id=\"七、设定执行方案\"><a href=\"#七、设定执行方案\" class=\"headerlink\" title=\"七、设定执行方案\"></a>七、设定执行方案</h2><p>1、设定目标的原则：先有大目标，再补充小目标；亦可先有小目标，再定大目标。</p>\n<p>2、执行计划：人生计划-五年计划-年度计划-月计划-周计划-日计划。</p>\n<p>3、注意“轻重缓急”的原则。</p>\n<p>4、实施“时间管理”，不断奋斗。</p>\n<p>5、每年配合环境变化及既有成就，随时修改。</p>\n<h2 id=\"八、生涯描绘\"><a href=\"#八、生涯描绘\" class=\"headerlink\" title=\"八、生涯描绘\"></a>八、生涯描绘</h2><h3 id=\"1、自我评价\"><a href=\"#1、自我评价\" class=\"headerlink\" title=\"1、自我评价\"></a>1、自我评价</h3><p>1）我的人生价值是什么？</p>\n<p>2）我的人格特质是什么？</p>\n<p>3）我这生最感兴趣的事情是什么？</p>\n<p>4）我现有的技能和条件有哪些？</p>\n<h3 id=\"2、自我探索\"><a href=\"#2、自我探索\" class=\"headerlink\" title=\"2、自我探索\"></a>2、自我探索</h3><p>让自己从上述自我评价中找出自己可行的生涯方向。不要受人影响。</p>\n<h3 id=\"3、锁定特定目标\"><a href=\"#3、锁定特定目标\" class=\"headerlink\" title=\"3、锁定特定目标\"></a>3、锁定特定目标</h3><p>设定一个旨在让自己设定一个值得而且愿意花最多时间去进行的目标。</p>\n<h3 id=\"4、生涯策略性计划（可行性）\"><a href=\"#4、生涯策略性计划（可行性）\" class=\"headerlink\" title=\"4、生涯策略性计划（可行性）\"></a>4、生涯策略性计划（可行性）</h3><p>1）为什么这个目标对我而言是最可能的目标？</p>\n<p>2）我将如何达成此一特定目标？</p>\n<p>3）我将分别在何时进行上述每一行动计划？</p>\n<p>4）有哪些人将会/应当加入此一行动计划？</p>\n<p>5）对我而言还有什么不能解决的问题呢？</p>\n<h3 id=\"九、总结：生涯定位\"><a href=\"#九、总结：生涯定位\" class=\"headerlink\" title=\"九、总结：生涯定位\"></a>九、总结：生涯定位</h3><p>1、给自己一个定位</p>\n<p>2、拟定生涯发展策略</p>\n<p>3、规划短程可行方案</p>\n<p>4、检讨与修改</p>\n<p><span style=\"color:red;font-size:xx-large;\"><strong>祝愿我们每个人的明天会更好！谢谢大家！</strong></span></p>\n","categories":["feeling"],"tags":["成长感悟","个人成长","职业规划"]},{"title":"位运算和移位运算","url":"/posts/61738.html","content":"<h2 id=\"一、位运算\"><a href=\"#一、位运算\" class=\"headerlink\" title=\"一、位运算\"></a>一、位运算</h2><p><strong>位运算符包括:　与（&amp;）、非（~）、或（|）、异或（^）</strong></p>\n<ul>\n<li>&amp;：相同位的两个数字都为1、则为1；若有一个不为1、则为0、<br> 例：00101 &amp; 11100 = 00100</li>\n<li>|：相同位只要一个为1即为1、<br> 例：00101 | 11100 = 11101</li>\n<li>~：运算的定义是把内存中的0和1全部取反、使用not运算时要格外小心、你需要注意整数类型有没有符号、如果not的对象是无符号整数（不能表示负数）、那么得到的值就是它与该类型上界的差、因为无符号类型的数是用00到$FFFF依次表示的、<br> 例：~‭00101 = 11010</li>\n<li>^：相同位不同则为1、相同则为0、<br> 例：00101 ^ 11100 = 11001</li>\n</ul>\n<span id=\"more\"></span>\n\n<p><em><strong>位运算与位移动运行符的一个场景</strong></em></p>\n<p>HashMap的功能是通过键(key)能够快速的找到“值”，下面我们分析下HashMap存数据的基本流程。</p>\n<ol>\n<li><p>当调用put(key、value)时、首先获取key的hashcode、</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> hash = key.hashCode();</span><br></pre></td></tr></table></figure></li>\n<li><p>再把hash通过一下运算得到一个int h、</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">hash ^= (hash &gt;&gt;&gt; <span class=\"number\">20</span>) ^ (hash &gt;&gt;&gt; <span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> h = hash ^ (hash &gt;&gt;&gt; <span class=\"number\">7</span>) ^ (hash &gt;&gt;&gt; <span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>为什么要经过这样的运算呢？这就是HashMap的高明之处、</strong></p>\n<ul>\n<li>一个十进制数32768(二进制1000 0000 0000 0000)、经过上述公式运算之后的结果是35080(二进制1000 1001 0000 1000)、</li>\n<li>看出来了吗？或许这样还看不出什么、再举个数字61440(二进制1111 0000 0000 0000)、运算结果是65263(二进制1111 1110 1110 1111)、</li>\n<li>现在应该很明显了、它的目的是让“1”变的均匀一点、散列的本意就是要尽量均匀分布、</li>\n</ul>\n</blockquote>\n</li>\n<li><p>得到h之后、把h与HashMap的承载量（HashMap的默认承载量length是16、可以自动变长、在构造HashMap的时候也可以指定一个长度、这个承载量就是上图所描述的数组的长度）进行逻辑与运算、即 h &amp; (length-1)、这样得到的结果就是一个比length小的正数、我们把这个值叫做index、其实这个index就是索引将要插入的值在数组中的位置、第2步那个算法的意义就是希望能够得出均匀的index、这是HashTable的改进、HashTable中的算法只是把key的 hashcode与length相除取余、即hash % length、这样有可能会造成index分布不均匀、还有一点需要说明、HashMap的键可以为null、它的值是放在数组的第一个位置、</p>\n</li>\n<li><p>我们用table[index]表示已经找到的元素需要存储的位置、先判断该位置上有没有元素(这个元素是HashMap内部定义的一个类Entity、基本结构它包含三个类、key、value和指向下一个Entity的next)、没有的话就创建一个Entity对象、在 table[index]位置上插入、这样插入结束、如果有的话、通过链表的遍历方式去逐个遍历、看看有没有已经存在的key、有的话用新的value替换老的value、如果没有、则在table[index]插入该Entity、把原来在table[index]位置上的Entity赋值给新的Entity的next、这样插入结束、</p>\n</li>\n</ol>\n<p><strong>附参：</strong><a href=\"http://www.iteye.com/topic/838030\">HashMap是列表与链表的结合体</a> </p>\n<hr>\n<h2 id=\"二、移位运算\"><a href=\"#二、移位运算\" class=\"headerlink\" title=\"二、移位运算\"></a>二、移位运算</h2><p><strong>通用的移位运算符两种：左移（&lt;&lt;）、带符号右移（&gt;&gt;）。PS：有些语言还有无符号右移（&gt;&gt;&gt;）。如：Java、C++</strong></p>\n<h4 id=\"1、左移位运算\"><a href=\"#1、左移位运算\" class=\"headerlink\" title=\"1、左移位运算\"></a>1、左移位运算</h4><p><strong>左移运算符&lt;&lt;使指定值的所有位都左移规定的次数</strong></p>\n<ol>\n<li>通用格式  <ul>\n<li>num指定要移位值value移动的位数、</li>\n<li>左移的规则只记住一点：丢弃最高位、0补最低位、</li>\n<li>如果移动的位数超过了该类型的最大位数、那么编译器会对移动的位数取模、</li>\n<li>如对int型移动33位、实际上只移动了33%32=1位、<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">value &lt;&lt; num;     <span class=\"comment\">// value左移num</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li>运算规则  <ul>\n<li>按二进制形式把所有的数字向左移动对应的位数、高位移出(舍弃)、低位的空位补零、</li>\n<li>当左移的运算数是int类型时、每移动1位它的第31位就要被移出并且丢弃、</li>\n<li>当左移的运算数是long类型时、每移动1位它的第63位就要被移出并且丢弃、</li>\n<li>当左移的运算数是byte和short类型时、将自动把这些类型扩大为 int 型、</li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li>数学意义<br> 在数字没有溢出的前提下、对于正数和负数、左移一位都相当于乘以2的1次方、左移n位就相当于乘以2的n次方、</li>\n</ol>\n<ol start=\"4\">\n<li><p>计算过程  </p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span> &lt;&lt; <span class=\"number\">2</span>;     <span class=\"comment\">// 3为int型</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011</li>\n<li>把高位（左侧）的两个数字移出、因为时左移操作、所以在低位补0</li>\n<li>最终结果是0000 0000 0000 0000 0000 0000 0000 1100</li>\n<li>转换为十进制是12</li>\n</ol>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">-<span class=\"number\">3</span> &lt;&lt; <span class=\"number\">2</span>;     <span class=\"comment\">// -3为int型</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>-3转换为二进制：‭1111 1111 1111 1111 1111 1111 1111 1101‬</li>\n<li>把高位（左侧）的两个数字移出、因为时左移操作、所以在低位补0</li>\n<li>最终结果是1111 1111 1111 1111 1111 1111 1111 0100</li>\n<li>转换为十进制是-12</li>\n</ol>\n<p> 转换为十进制是12、移动的位数超过了该类型的最大位数、同理、&gt;&gt;表示右移、右移一位表示除2、<br> 如果移进高阶位(31或63位)、那么该值将变为负值、下面的程序说明了这一点、</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MultByTwo</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> i;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">0xFFFFFFE</span>;   </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">4</span>; i++) &#123;  </span><br><span class=\"line\">            num = num &lt;&lt; <span class=\"number\">1</span>;   </span><br><span class=\"line\">            System.out.println(num);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 该程序的输出如下所示：<br> 536870908<br> 1073741816<br> 2147483632<br> -32  </p>\n<p> 注：n位二进制、最高位为符号位、因此表示的数值范围-2^(n-1) —— 2^(n-1)-1、所以模为2^(n-1)、 </p>\n</li>\n</ol>\n<h4 id=\"2、右移位运算\"><a href=\"#2、右移位运算\" class=\"headerlink\" title=\"2、右移位运算\"></a>2、右移位运算</h4><p><strong>右移运算符&gt;&gt;使指定值的所有位都右移规定的次数</strong></p>\n<ol>\n<li>通用格式  <ul>\n<li>num 指定要移位值value移动的位数、</li>\n<li>右移的规则只记住一点：符号位不变、左边补上符号位、<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">value &gt;&gt; num;     <span class=\"comment\">// value右移num</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li>运算规则  <ul>\n<li>按二进制形式把所有的数字向右移动对应的位数、低位移出(舍弃)、高位的空位补符号位、即正数补零、负数补1、  </li>\n<li>当右移的运算数是byte和short类型时、将自动把这些类型扩大为int型、  <blockquote>\n<p>例如：如果要移走的值为负数、每一次右移都在左边补1、<br>如果要移走的值为正数、每一次右移都在左边补0、<br>这叫做符号位扩展(保留符号位)(sign extension)、在进行右移操作时用来保持负数的符号、  </p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li>数学意义<br> 右移一位相当于除2、右移n位相当于除以2的n次方、</li>\n</ol>\n<ol start=\"4\">\n<li><p>计算过程  </p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span> &gt;&gt; <span class=\"number\">2</span>;     <span class=\"comment\">// 11为int型</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>11转换为二进制：0000 0000 0000 0000 0000 0000 0000 1011</li>\n<li>把低位（右侧）两个数字移出、因为该数字是正数、所以在高位补0</li>\n<li>最终结果是0000 0000 0000 0000 0000 0000 0000 0010</li>\n<li>转换为十进制是2</li>\n</ol>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">-<span class=\"number\">11</span> &gt;&gt; <span class=\"number\">2</span>;     <span class=\"comment\">// -11为int型</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>-11转换为二进制：1111 1111 1111 1111 1111 1111 1111 0101‬</li>\n<li>把低位（右侧）的两个数字移出、因为该数字是负数、所以在高位补1</li>\n<li>最终结果是1111 1111 1111 1111 1111 1111 1111 1101</li>\n<li>转换为十进制是-3</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3、无符号右移\"><a href=\"#3、无符号右移\" class=\"headerlink\" title=\"3、无符号右移\"></a>3、无符号右移</h4><p>关于无符号右移就不详细说明了、大致解释一下、毕竟移位运算都差不多、无符号右移运算符：&gt;&gt;&gt; </p>\n<ol>\n<li><p>通用格式</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">value &gt;&gt;&gt; num;    <span class=\"comment\">// num指定要移位值value移动的位数</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>无符号右移的规则：忽略了符号位扩展、0补最高位、<br>无符号右移运算符&gt;&gt;&gt;只是对32位和64位的值有意义、  </p>\n","categories":["basis"],"tags":["位运算","移位运算","左移位","右移位","无符号移位"]},{"title":"这些话很能表达我最近一次换工作的感受","url":"/posts/36417.html","content":"<h1 id=\"一、跳槽穷半年、改行穷三年\"><a href=\"#一、跳槽穷半年、改行穷三年\" class=\"headerlink\" title=\"一、跳槽穷半年、改行穷三年\"></a>一、跳槽穷半年、改行穷三年</h1><ol>\n<li><p>不要轻易离开团队、否则你要从零做起、</p>\n</li>\n<li><p>不要老想着做不顺就放弃、哪个团队都有问题、哪个团队都有优点、</p>\n</li>\n<li><p>跟对领导很重要、愿意教你的、放手让你做的领导、绝对要珍惜、</p>\n</li>\n<li><p>团队的问题就是你脱颖而出的机会、抱怨和埋怨团队就是打自己耳光、说自己无能、更是在放弃机会、</p>\n</li>\n<li><p>心怀感恩之心、感谢系统给你平台、感谢伙伴给你配合、</p>\n</li>\n<li><p>创造利润是你存在的核心价值、创业不是做慈善、</p>\n</li>\n<li><p>遇到问题请先思考、只反映问题是初级水平、思考并解决问题才是高级水平、</p>\n</li>\n</ol>\n<span id=\"more\"></span>\n\n<h1 id=\"二、谁能最后享受到胜利成果\"><a href=\"#二、谁能最后享受到胜利成果\" class=\"headerlink\" title=\"二、谁能最后享受到胜利成果\"></a>二、谁能最后享受到胜利成果</h1><ol>\n<li><p>能始终跟着团队一起成长的人、</p>\n</li>\n<li><p>对团队的前景始终看好的人、</p>\n</li>\n<li><p>在团队不断的探索中能找到自己位置的人、</p>\n</li>\n<li><p>为了团队新的目标不断学习新东西的人、</p>\n</li>\n<li><p>抗压能力强且有耐性的人、</p>\n</li>\n<li><p>与团队同心同德、同舟共济、同甘共苦的人、</p>\n</li>\n<li><p>不计较个人得失、顾全大局的人、</p>\n</li>\n<li><p>雄心博大、德才兼备、有奉献的人</p>\n</li>\n</ol>\n<h1 id=\"三、坚持不一定成功\"><a href=\"#三、坚持不一定成功\" class=\"headerlink\" title=\"三、坚持不一定成功\"></a>三、坚持不一定成功</h1><blockquote>\n<p>学会说话、给人温暖、给人鼓励、给人赞美、</p>\n<p>给人信心、给人方便、给人希望、给人智慧、</p>\n</blockquote>\n<h1 id=\"四、好好工作吧\"><a href=\"#四、好好工作吧\" class=\"headerlink\" title=\"四、好好工作吧\"></a>四、好好工作吧</h1><p><strong>既然什么也改变不了、除了好好工作还能做什么！</strong></p>\n","categories":["feeling"],"tags":["成长感悟"]},{"title":"IO的概念和5种IO模型","url":"/posts/52540.html","content":"<h1 id=\"一、什么是IO？\"><a href=\"#一、什么是IO？\" class=\"headerlink\" title=\"一、什么是IO？\"></a>一、什么是IO？</h1><p>我们都知道unix世界里、一切皆文件、而文件是什么呢？文件就是一串二进制流而已、不管socket、还是FIFO、管道、终端、对我们来说、一切都是文件、一切都是流、在信息交换的过程中、我们都是对这些流进行数据的收发操作、简称为I/O操作(input and output)、往流中读出数据、系统调用read、写入数据、系统调用write、不过话说回来了、计算机里有这么多的流、我怎么知道要操作哪个流呢？做到这个的就是文件描述符、即通常所说的fd、一个fd就是一个整数、所以对这个整数的操作、就是对这个文件（流）的操作、我们创建一个socket、通过系统调用会返回一个文件描述符、那么剩下对socket的操作就会转化为对这个描述符的操作、不能不说这又是一种分层和抽象的思想、  </p>\n<p><em><strong>PS：本文中的IO概念只针对缓冲IO、具体可以阅读<a href=\"https://www.msyy233.com/posts/51696.html\">缓存IO、直接IO与内存映射</a></strong></em></p>\n<h1 id=\"二、IO交互\"><a href=\"#二、IO交互\" class=\"headerlink\" title=\"二、IO交互\"></a>二、IO交互</h1><p>通常用户进程中的一个完整IO分为两阶段：<br><img src=\"http://assets.msyy233.com/20180607/112239bb4.png!blog\" alt=\"IO交互图_1\">  </p>\n<ol>\n<li>用户空间 &lt;—–&gt; 内核空间、</li>\n<li>内核空间 &lt;—–&gt; 设备空间、</li>\n</ol>\n<span id=\"more\"></span>\n\n<blockquote>\n<p><img src=\"http://assets.msyy233.com/20180608/10015061c.png!blog\" alt=\"IO交互图_2\">  </p>\n<p>内核空间中存放的是内核代码和数据、而进程的用户空间中存放的是用户程序的代码和数据、不管是内核空间还是用户空间、它们都处于虚拟空间中、Linux使用两级保护机制：0级供内核使用、3级供用户程序使用、  </p>\n<p>操作系统和驱动程序运行在内核空间、应用程序运行在用户空间、两者不能简单地使用指针传递数据、因为Linux使用的虚拟内存机制、其必须通过系统调用请求kernel来协助完成IO动作、内核会为每个IO设备维护一个缓冲区、用户空间的数据可能被换出、当内核空间使用用户空间指针时、对应的数据可能不在内存中  </p>\n<p>对于一个输入操作来说、进程IO系统调用后、内核会先看缓冲区中有没有相应的缓存数据、没有的话再到设备中读取、因为设备IO一般速度较慢、需要等待、内核缓冲区有数据则直接复制到进程空间、  </p>\n</blockquote>\n<p>所以、对于一个网络输入操作通常包括两个不同阶段：<br>（1）等待网络数据到达网卡 –&gt; 读取到内核缓冲区<br>（2）从内核缓冲区复制数据 –&gt; 用户空间  </p>\n<p>IO有内存IO、网络IO和磁盘IO三种、通常我们说的IO指的是后两者</p>\n<h1 id=\"三、POSIX\"><a href=\"#三、POSIX\" class=\"headerlink\" title=\"三、POSIX\"></a>三、POSIX</h1><p>对IO底层交互感兴趣的小伙伴可以好好了解一下POSIX（Portable Operating System Interface for Computing System）、我对深沉次原理也不怎么熟、之所以写此篇博文也是为了后面的Java IO学习、深入浅出点到即可、此章节给有兴趣的朋友一个引子、</p>\n<h1 id=\"四、IO模型\"><a href=\"#四、IO模型\" class=\"headerlink\" title=\"四、IO模型\"></a>四、IO模型</h1><p>《UNIX网络编程》说得很清楚、5种IO模型分别是阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动的IO模型、异步IO模型、前4种为同步IO操作、只有异步IO模型是异步IO操作、<strong>请仔细阅读IO交互便于理解IO模型</strong></p>\n<h2 id=\"（一）阻塞IO模型\"><a href=\"#（一）阻塞IO模型\" class=\"headerlink\" title=\"（一）阻塞IO模型\"></a>（一）阻塞IO模型</h2><p><img src=\"http://assets.msyy233.com/20180621/1458454e1.png!blog\" alt=\"阻塞IO模型\"><br>当用户进程调用了recvfrom这个系统调用、内核就开始了IO的第一个阶段：准备数据、对于网络IO来说、很多时候数据在一开始还没有到达（比如、还没有收到一个完整的UDP包）、这个时候内核就要等待足够的数据到来、而在用户进程这边、整个进程会被阻塞、当内核一直等到数据准备好了、它就会将数据从内核中拷贝到用户内存、然后返回结果、用户进程才解除阻塞的状态、重新运行起来、几乎所有的程序员第一次接触到的网络编程都是从listen()、send()、recv()等接口开始的、这些接口都是阻塞型的、</p>\n<blockquote>\n<p><strong>blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被阻塞了、</strong>  </p>\n<p>典型应用：阻塞Socket、Java BIO</p>\n<ul>\n<li>进程阻塞挂起不消耗CPU资源、及时响应每个操作  </li>\n<li>实现难度低、开发应用较容易  </li>\n<li>适用并发量小的网络应用开发   </li>\n<li>不适用并发量大的应用、因为一个请求IO会阻塞进程、所以、得为每请求分配一个处理进程（线程）以及时响应、系统开销大  </li>\n</ul>\n</blockquote>\n<h2 id=\"（二）非阻塞IO模型\"><a href=\"#（二）非阻塞IO模型\" class=\"headerlink\" title=\"（二）非阻塞IO模型\"></a>（二）非阻塞IO模型</h2><p><img src=\"http://assets.msyy233.com/20180621/145910c91.png!blog\" alt=\"非阻塞IO模型\"><br>当用户进程发出read操作时、如果内核中的数据还没有准备好、那么它并不会block用户进程、而是立刻返回一个error、从用户进程角度讲、它发起一个read操作后、并不需要等待、而是马上就得到了一个结果、用户进程判断结果是一个error时、它就知道数据还没有准备好、于是它可以再次发送read操作、一旦内核中的数据准备好了、并且又再次收到了用户进程的系统调用、那么它马上就将数据拷贝到了用户内存、然后返回、非阻塞的接口相比于阻塞型接口的显著差异在于、在被调用之后立即返回、</p>\n<blockquote>\n<p><strong>在非阻塞式IO中、用户进程其实是需要不断的主动询问kernel数据准备好了没有</strong> </p>\n<p>典型应用：Socket 设置 NONBLOCK</p>\n<ul>\n<li>进程轮询（重复）调用、消耗CPU的资源</li>\n<li>实现难度低、开发应用相对阻塞IO模式较难</li>\n<li>适用并发量较小、且不需要及时响应的网络应用开发</li>\n</ul>\n</blockquote>\n<h2 id=\"（三）IO复用模型\"><a href=\"#（三）IO复用模型\" class=\"headerlink\" title=\"（三）IO复用模型\"></a>（三）IO复用模型</h2><p><img src=\"http://assets.msyy233.com/20180621/145932209.png!blog\" alt=\"IO复用模型\"><br>多个的进程的IO可以注册到一个复用器（select）上、当用户进程调用该select、select会监听所有注册进来的IO、如果select所有监听的IO在内核缓冲区都没有可读数据、select调用进程会被阻塞、而当任一IO在内核缓冲区中有可数据时、select调用就会返回、而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO、读取内核中准备好的数据、多个进程注册IO后、只有一个select调用进程被阻塞</p>\n<p>IO复用相对阻塞和非阻塞更难简单说明、所以额外解释一段、其实IO复用模型和阻塞IO模型并没有太大的不同、事实上、还更差一些、因为这里需要使用两个系统调用（select和 recvfrom）、而阻塞IO模型只有一次系统调用(recvfrom)、但是、用select的优势在于它可以同时处理多个连接、所以如果处理的连接数不是很高的话、使用select/epoll的web server不一定比使用多线程加阻塞IO的web server性能更好、可能延迟还更大、select/epoll的优势并不是对于单个连接能处理得更快、而是在于能处理更多的连接</p>\n<blockquote>\n<p><strong>在IO复用模型中、对于每一个socket、一般都设置成为非阻塞、但是、如上图所示、整个用户的进程其实是一直被阻塞的、只不过进程是被select这个函数阻塞、而不是被socket IO给阻塞</strong></p>\n<p>典型应用：Java NIO、Nginx（epoll、poll、select）</p>\n<ul>\n<li>专一进程解决多个进程IO的阻塞问题、性能好、Reactor模式</li>\n<li>实现、开发应用难度较大</li>\n<li>适用高并发服务应用开发、一个进程/线程响应多个请求</li>\n</ul>\n</blockquote>\n<h2 id=\"（四）信号驱动式IO模型\"><a href=\"#（四）信号驱动式IO模型\" class=\"headerlink\" title=\"（四）信号驱动式IO模型\"></a>（四）信号驱动式IO模型</h2><p><img src=\"http://assets.msyy233.com/20180621/15000524a.png!blog\" alt=\"信号驱动式IO模型\"><br>信号驱动式IO就是指进程预先告知内核、向内核注册一个信号处理函数、然后用户进程返回不阻塞、当内核数据就绪时会发送一个信号给进程、用户进程便在信号处理函数中调用IO读取数据、从图中明白实际IO内核拷贝到用户进程的过程还是阻塞的、信号驱动式IO并没有实现真正的异步、因为通知到进程之后、依然是由进程来完成IO操作、</p>\n<p>信号驱动的作用在于在等待IO可用的过程中可以执行其它的指令，这种方法从理论上看倒是不错、由于进程已经休眠、就不会再占用CPU、仅当IO可用时它才恢复执行、但是这种方法的问题在于信号处理的开销有点大、若只是少数的请求还没有问题、若是每分钟收到100个请求、那就几乎一直都在捕获信号、每秒钟捕获上百个信号的开销是相当大的、不单是进程、对于内核发送信号的开销而言也是一样的</p>\n<p>这和后面的异步IO模型很容易混淆、需要理解<a href=\"#%E4%BA%8C%E3%80%81IO%E4%BA%A4%E4%BA%92\">IO交互</a>并结合<a href=\"#%EF%BC%88%E5%85%AD%EF%BC%89%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83\">五种IO模型的比较</a>阅读</p>\n<blockquote>\n<p><strong>在信号驱动式IO模型中、依然不符合POSIX描述的异步IO、只能算是半异步、并且实际中并不常用、</strong></p>\n<p>典型应用：（不知道）</p>\n<ul>\n<li>回调机制、实现、开发应用难度大</li>\n</ul>\n</blockquote>\n<h2 id=\"（五）异步IO模型\"><a href=\"#（五）异步IO模型\" class=\"headerlink\" title=\"（五）异步IO模型\"></a>（五）异步IO模型</h2><p><img src=\"http://assets.msyy233.com/20180621/15010130e.png!blog\" alt=\"异步IO模型\"><br>用户进程发起aio_read（POSIX异步IO函数aio_或者lio_开头）操作之后、给内核传递描述符、缓冲区指针、缓冲区大小和read相同的三个参数以及文件偏移（与lseek类似）、告诉内核当整个操作完成时、如何通知我们、立刻就可以开始去做其它的事、而另一方面、从内核的角度、当它受到一个aio_read之后、首先它会立刻返回、所以不会对用户进程产生任何阻塞、然后、内核会等待数据准备完成、然后将数据拷贝到用户内存、当这一切都完成之后、内核会给用户进程发送一个信号、告诉它aio_read操作完成了</p>\n<p>异步IO的工作机制是：告知内核启动某个操作、并让内核在整个操作完成后通知我们、这种模型与信号驱动的IO区别在于、信号驱动IO是由内核通知我们何时可以启动一个IO操作、这个IO操作由用户自定义的信号函数来实现、而异步IO模型是由内核告知我们IO操作何时完成、</p>\n<p>这和前面的信号驱动式IO模型很容易混淆、需要理解<a href=\"#%E4%BA%8C%E3%80%81IO%E4%BA%A4%E4%BA%92\">IO交互</a>并结合<a href=\"#%EF%BC%88%E5%85%AD%EF%BC%89%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83\">五种IO模型的比较</a>阅读</p>\n<blockquote>\n<p><strong>在异步IO模型中、真正实现了POSIX描述的异步IO、是五种IO模型中唯一的异步模型</strong></p>\n<p>典型应用：Java 7 AIO、高性能服务器应用</p>\n<ul>\n<li>不阻塞、数据一步到位、Proactor模式</li>\n<li>需要操作系统的底层支持、LINUX 2.5 版本内核首现、2.6 版本产品的内核标准特性</li>\n<li>回调机制、实现、开发应用难度大</li>\n<li>非常适合高性能高并发应用</li>\n</ul>\n</blockquote>\n<h2 id=\"（六）五种IO模型的比较\"><a href=\"#（六）五种IO模型的比较\" class=\"headerlink\" title=\"（六）五种IO模型的比较\"></a>（六）五种IO模型的比较</h2><p><img src=\"http://assets.msyy233.com/20180623/114549991.png!blog\" alt=\"5个IO模型的比较\"></p>\n<ol>\n<li>阻塞IO和非阻塞IO的区别在哪？<br>前面的介绍中其实已经很明确的说明了这两者的区别、调用阻塞会一直阻塞住对应的进程直到操作完成、而非阻塞IO在内核还没准备数据的情况下会立刻返回、阻塞和非阻塞关注的是进程在等待调用结果时的状态、阻塞是指调用结果返回之前、当前进程会被挂起、调用进程只有在得到结果才会返回、非阻塞调用指不能立刻得到结果、该调用不会阻塞当前进程、</li>\n<li>同步IO和异步IO区别在哪？<br>两者的区别就在于同步做IO操作的时候会将进程阻塞、按照这个定义、之前所述的阻塞IO、非阻塞IO、IO复用、信号驱动都属于同步IO、有人可能会说、非阻塞IO并没有被阻塞啊、这里有个非常狡猾的地方、定义中所指的IO操作是指真实的IO操作、就是例子中的recvfrom这个系统调用、非阻塞IO在执行recvfrom这个系统调用的时候、如果内核的数据没有准备好、这时候不会阻塞进程、但是、当内核中数据准备好的时候、recvfrom会将数据从内核拷贝到用户内存中、这个时候进程是被阻塞了、信号驱动也是同样的道理、在这段时间内、进程是被阻塞的、而异步IO则不一样、当进程发起IO操作之后、就直接返回再也不理睬了、直到内核发送一个信号、告诉进程说IO完成、在这整个过程中、进程完全没有被阻塞、<blockquote>\n<p><strong>同异步IO的根本区别在于、同步IO主动的调用recvfrom来将数据拷贝到用户内存、而异步则完全不同、它就像是用户进程将整个IO操作交给了他人（内核）完成、然后他人做完后发信号通知、在此期间、用户进程不需要去检查IO操作的状态、也不需要主动的去拷贝数据</strong> </p>\n<p>POSIX的定义:<br>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes<br>An asynchronous I/O operation does not cause the requesting process to be blocked  </p>\n</blockquote>\n</li>\n<li>信号驱动式IO和异步IO的区别？<br>这里之所以单独拿出来是因为如果还没有清除IO概念很容易混淆、所以理解IO模型之前一定要理解IO概念、如果看完前面两个问题、相信也能理解信号驱动IO与异步IO的区别在于启用异步IO意味着通知内核启动某个IO操作、并让内核在整个操作（<strong>包括数据从内核复制到用户缓冲区</strong>）完成时通知我们、也就是说、异步IO是由内核通知我们IO操作何时完成、即实际的IO操作也是异步的、信号驱动IO是由内核通知我们何时可以启动一个IO操作、这个IO操作由用户自定义的信号函数来实现<blockquote>\n<p>I/O究竟什么时候能用这个信息实际上只有内核才能事先知道、因为是内核在最终处理系统中的所有打开的描述符</p>\n<p>信号驱动IO模型:<br>内核：IO能用了<br>进程：接受到IO能用的消息并执行接下来的操作</p>\n<p>异步I/O模型<br>内核：等待这个IO有消息了、接受到数据<br>进程：从缓存（用户空间）中得到数据</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h1><p><strong>全篇最大的难点在于真正理解数据是如何从设备空间扭转到内核空间再到用户空间</strong></p>\n","categories":["io"],"tags":["io模型","nio","io","aio","bio"]},{"title":"缓存IO、直接IO与内存映射","url":"/posts/51696.html","content":"<p>文件系统IO分为Direct IO和Buffer IO、其中BufferIO也叫Normal IO、除此之外还有一个MMAP内存映射技术、<strong>由于涉及很多Linux内核知识、所以这里只讲述关键的知识点、用于学习Java NIO的时候不会太过疑惑</strong>、其余详细的系统底层知识有机会额外花时间讲述、</p>\n<h1 id=\"一、缓存IO\"><a href=\"#一、缓存IO\" class=\"headerlink\" title=\"一、缓存IO\"></a>一、缓存IO</h1><p>多数文件系统的默认IO操作都是缓存IO、在Linux的缓存IO机制中、操作系统会将IO的数据缓存在文件系统的页缓存（page cache）中、也就是说、数据会先被拷贝到操作系统内核的缓冲区中、然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间、这里可以看看<a href=\"https://www.msyy233.com/posts/52540.html\">IO的概念和5种IO模型</a>中的IO交互章节、下面是两张概念图、第二张更简洁便于理解、</p>\n<span id=\"more\"></span>\n<p><img src=\"http://assets.msyy233.com/20180902/15562879f.png!blog\" alt=\"缓存IO1\"></p>\n<p><img src=\"http://assets.msyy233.com/20180904/224713f87.png!blog\" alt=\"缓存IO2\"></p>\n<p>缓存IO优点：</p>\n<ol>\n<li>在一定程度上分离了内核空间和用户空间、保护系统本身的运行安全</li>\n<li>减少读盘的次数、从而提高性能</li>\n</ol>\n<p>缓存IO缺点：</p>\n<ol>\n<li>应用程序地址空间（用户空间）和缓存（内核空间）之间进行多次数据拷贝操作、这些数据拷贝操作所带来的CPU以及内存开销是非常大的</li>\n</ol>\n<blockquote>\n<p><strong>自缓存应用（self-caching applications）</strong><br>但是对于某些特殊的应用程序来说、避开操作系统内核缓冲区而直接在应用程序地址空间和磁盘之间传输数据会比使用操作系统内核缓冲区获取更好的性能、自缓存应用程序就是其中的一种、自缓存应用程序会有它自己的数据缓存机制、比如它会将数据缓存在应用程序地址空间、这类应用程序完全不需要使用操作系统内核中的高速缓冲存储器、<strong>数据库管理系统是这类应用程序的一个代表、</strong><br>对于自缓存应用程序来说、缓存IO明显不是一个好的选择、由此引出下一章要介绍的Linux中的直接IO技术、Linux中的直接IO技术非常适用于自缓存这类应用程序、该技术省略掉缓存IO技术中操作系统内核缓冲区的使用、数据直接在应用程序地址空间和磁盘之间进行传输、从而使得自缓存应用程序可以省略掉复杂的系统级别的缓存结构、而执行程序自己定义的数据读写管理、从而降低系统级别的管理对应用程序访问数据的影响、</p>\n</blockquote>\n<h1 id=\"二、直接IO\"><a href=\"#二、直接IO\" class=\"headerlink\" title=\"二、直接IO\"></a>二、直接IO</h1><p>在这一章中简单介绍一下Linux中提供的直接IO机制、该机制为自缓存应用程序提供了很好的支持、因为上一章引用也说了自缓存应用、所以不再详细介绍、直接IO中数据均直接在用户地址空间（用户空间）和磁盘之间直接进行传输、完全不需要页缓存的支持、同样是两张概念图、</p>\n<p><img src=\"http://assets.msyy233.com/20180902/155905e63.png!blog\" alt=\"直接IO1\"></p>\n<p><img src=\"http://assets.msyy233.com/20180904/224339bed.png!blog\" alt=\"直接IO2\"></p>\n<p>直接IO优点：</p>\n<ol>\n<li>减少一次从内核缓冲区到用户程序缓存的数据复制、这种访问文件的方式通常是在对数据的缓存管理由应用程序实现的数据库管理系统中、应用程序明确地知道应该缓存哪些数据、应该失效哪些数据、操作系统只是简单地缓存最近一次从磁盘读取的数据、</li>\n</ol>\n<p>直接IO缺点:</p>\n<ol>\n<li>如果访问的数据不在应用程序缓存中、那么每次访问数据都会直接从磁盘加载、这种直接加载会非常缓慢</li>\n</ol>\n<h1 id=\"三、内存映射\"><a href=\"#三、内存映射\" class=\"headerlink\" title=\"三、内存映射\"></a>三、内存映射</h1><p>如果说直接IO和缓存IO是相对的、而内存映射是另外一个概念、这里先给出<a href=\"http://man7.org/linux/man-pages/man2/mmap.2.html\">nmap官方文档</a>、反正我是看不懂、不过这章我会详细配图讲解、因为IO系列博客主要是为了学习Java NIO、而Java NIO中的直接IO使用的其实是内存映射技术、这里很多内容来自书籍《深入分析Java Web技术内幕》以及参考资料、  </p>\n<p><img src=\"http://assets.msyy233.com/20180902/155933022.png!blog\" alt=\"内存映射1\"></p>\n<p><img src=\"http://assets.msyy233.com/20180904/22502433f.png!blog\" alt=\"内存映射2\"></p>\n<blockquote>\n<p>内存映射方式是指操作系统将内存中的某一块区域与磁盘中的文件关联起来、当要访问内存中一段数据时、转换为访问文件的某一段数据、这种方式的目的同样是减少数据从内核空间缓存到用户空间缓存的数据复制操作、因为这两个空间的数据是共享的、</p>\n</blockquote>\n<p><em><strong>Java NIO Buffer中的非直接缓冲区指的就是缓存IO、而直接缓冲区并不是Linux概念上面的直接IO、而是内存映射、请看下面的对比图、</strong></em></p>\n<p><img src=\"http://assets.msyy233.com/20180904/2300473bb.png!blog\" alt=\"非直接缓冲区\"><br><img src=\"http://assets.msyy233.com/20180904/230120c43.png!blog\" alt=\"直接缓冲区\">  </p>\n<p>Java NIO中建立直接缓冲区、其实是在JVM内存外开辟内存、在每次调用基础操作系统的一个本机IO之前或者之后、虚拟机都会避免将缓冲区的内容复制到中间缓冲区（或者从中间缓冲区复制内容）、缓冲区的内容驻留在物理内存内、会少一次复制过程、如果需要循环使用缓冲区、用直接缓冲区可以很大地提高性能、虽然直接缓冲区使JVM可以进行高效的IO操作、但它使用的内存是操作系统分配的、绕过了JVM堆栈、<strong>nmap的建立和销毁比堆栈上的缓冲区要更大的开销、</strong>  </p>\n<p>这里既然说下重点、博主的知识并没有这么深度、但是看过一些文章、以下内容来自其中<a href=\"https://mp.weixin.qq.com/s/aQtaDdnGxoGLvmXf7iuhLQ\">一篇</a></p>\n<ol>\n<li>nmap在Java中一次只能映射1.5~2G的文件内存、如果是更大的文件、要么需要对文件做物理拆分、切分成多文件、要么需要对文件映射做逻辑拆分、大文件分段映射、RocketMQ也使用了nmap、但是它通过限制了单文件大小来避免这个问题。</li>\n<li>nmap之所以快、是因为借助了内存来加速、mappedByteBuffer的put行为实际是对内存进行的操作、实际的刷盘行为依赖于操作系统的定时刷盘或者手动调用mappedByteBuffer.force()接口来刷盘、否则将会导致机器卡死（实测后的结论）、如果内存优先、那么使用nmap存在较难的控制问题、这也是为什么RocketMQ默认配置就是8G内存、另外RocketMQ实现中也存在定时force线程</li>\n</ol>\n<p><strong>nmap在内存较为富足并且数据量小的场景下存在优势（大多数文章的结论认为nmap适合大文件的读写、可能不是很严谨）</strong></p>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><p>没啥好总结的、因为这篇就是网上总结的、</p>\n<p><strong>参考资料：</strong><br><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-directio/\">Linux中直接I/O机制的介绍</a><br><a href=\"https://www.cnblogs.com/wuchanming/p/4360277.html\">Linux用户空间与内核空间（理解高端内存）</a><br><a href=\"https://www.cnblogs.com/stevenczp/p/7496089.html\">缓冲IO/直接IO/内存映射</a>  </p>\n","categories":["io"],"tags":["nio","io","直接IO","内存映射","MMAP","缓存IO","Linux"]},{"title":"Java NIO系列（一）核心组件","url":"/posts/49866.html","content":"<p>看过<a href=\"https://www.msyy233.com/posts/52540.html\">IO概念和5种IO模型</a>、可以了解到IO的五种模型、NIO便是对应其中的<em><strong>IO复用模型</strong></em>、本篇对NIO的组件进行讲解、如果还不理解什么是NIO建议先看一看上一篇<a href=\"https://www.msyy233.com/posts/52540.html\">IO概念和5种IO模型</a>、</p>\n<p>Java NIO是由以下几个核心部分组成：</p>\n<ul>\n<li>Channels</li>\n<li>Buffers</li>\n<li>Selectors</li>\n</ul>\n<blockquote>\n<p>虽然Java NIO 中除此之外还有很多类和组件、但在我看来Channel、Buffer和Selector构成了核心的API、其它组件、如Pipe和FileLock、只不过是与三个核心组件共同使用的工具类、</p>\n</blockquote>\n<span id=\"more\"></span>\n<hr>\n<h1 id=\"一、缓冲区（Buffer）\"><a href=\"#一、缓冲区（Buffer）\" class=\"headerlink\" title=\"一、缓冲区（Buffer）\"></a>一、缓冲区（Buffer）</h1><h2 id=\"（一）基本概念\"><a href=\"#（一）基本概念\" class=\"headerlink\" title=\"（一）基本概念\"></a>（一）基本概念</h2><p>缓冲区（Buffer）是一个用于特定基本数据类型的容器、由java.nio包定义的、所有缓冲区都是Buffer抽象类的子类、Java NIO中的Buffer主要用于与NIO通道进行交互、数据是从通道（Channel）读入缓冲区、从缓冲区写入通道中、</p>\n<blockquote>\n<p>缓冲区对象本质上是一个数组、但它其实是一个特殊的数组、缓冲区对象内置了一些机制、能够跟踪和记录缓冲区的状态变化情况、如果我们使用get()方法从缓冲区获取数据或者使用put()方法把数据写入缓冲区、都会引起缓冲区状态的变化、它可以保存多个相同类型的数据、根据数据类型不同（Boolean 除外）、有以下Buffer常用子类：</p>\n<ul>\n<li>ByteBuffer</li>\n<li>CharBuffer</li>\n<li>ShortBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>FloatBuffer</li>\n<li>DoubleBuffer</li>\n</ul>\n<p>上述Buffer类他们都采用相似的方法进行管理数据、只是各自管理的数据类型不同而已、<strong>简单的理解就是不同类型的特殊数组、</strong>   </p>\n</blockquote>\n<p>以上几种Buffer中都提供了一个allocate静态方法用于创建自身对象、传入一个int类型的capacity参数、其实就是数组的大小：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">IntBuffer intBuffer = IntBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">FloatBuffer floatBuffer = FloatBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">CharBuffer charBuffer = CharBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">DoubleBuffer doubleBuffer = DoubleBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">ShortBuffer shortBuffer = ShortBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">LongBuffer longBuffer = LongBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"comment\">// allocateDirect应用了内存映射技术</span></span><br><span class=\"line\">ByteBuffer directByteBuffer = ByteBuffer.allocateDirect(<span class=\"number\">1024</span>)</span><br><span class=\"line\">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br></pre></td></tr></table></figure>\n<p>可以看到除了allocate方法、ByteBuffer还提供了一个allocateDirect方法、和其他的构造方法不一样、allocate创建的HeapXXX的Buffer底层实现都是数组、而allocateDirect是基于内存映射技术的缓冲区、两种缓冲区分别是直接缓冲区和非直接缓冲区、这两个缓冲区涉及系统底层概念、不了解的可以看这篇<a href=\"https://www.msyy233.com/posts/51696.html\">缓存IO、直接IO与内存映射区</a>来解惑、</p>\n<h2 id=\"（二）工作原理\"><a href=\"#（二）工作原理\" class=\"headerlink\" title=\"（二）工作原理\"></a>（二）工作原理</h2><p><strong>为了理解Buffer的工作原理、需要熟悉它最重要的三个属性（capacity、position、limit）、它们一起合作完成对缓冲区内部状态的变化跟踪、</strong></p>\n<p><img src=\"http://assets.msyy233.com/20180830/150559eaf.png!blog\" alt=\"Buffer结构\"> </p>\n<ul>\n<li>capacity：<br>指定了可以存储在缓冲区中的最大数据容量、实际上、它指定了底层数组的大小、或者至少是指定了准许我们使用的底层数组的容量、一旦Buffer满了、需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据、</li>\n<li>position：<br>指定了下一个将要被写入或者读取的元素索引、它的值由get()/put()方法自动更新、在新创建一个Buffer对象时、position被初始化为0、当数据写到Buffer后、position会向前移动到下一个可插入数据的Buffer单元、position最大可为capacity – 1</li>\n<li>limit：<br>指定还有多少数据需要取出（在从缓冲区写入通道时）、或者还有多少空间可以放入数据（在从通道读入缓冲区时）、比如在写模式下、Buffer的limit表示你最多能往Buffer里写多少数据、当为写模式时、limit等于Buffer的capacity、而读模式、limit表示实际写入多少数据的点、 </li>\n</ul>\n<p>position和limit的含义取决于Buffer处在读模式还是写模式、不管Buffer处在什么模式、capacity的含义总是一样的、 </p>\n<p><strong>下面是Buffer操作的简单Demo：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.nio.ByteBuffer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> java.nio.charset.StandardCharsets.UTF_8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BufferDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定义写入数据</span></span><br><span class=\"line\">        String str = <span class=\"string\">&quot;Hello Buffer !&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 创建1024的ByteBuffer</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 此时为写模式：</span></span><br><span class=\"line\"><span class=\"comment\">         * capacity = limit = 1024</span></span><br><span class=\"line\"><span class=\"comment\">         * position = 0</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        ByteBuffer buffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* 写入数据 */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">byte</span> strByte : str.getBytes(UTF_8)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* 每写一次position + 1 */</span></span><br><span class=\"line\">            buffer.put(strByte);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         *  切换到读模式</span></span><br><span class=\"line\"><span class=\"comment\">         *  capacity = 1024;</span></span><br><span class=\"line\"><span class=\"comment\">         *  limit = position; // 之前写入的数据大小</span></span><br><span class=\"line\"><span class=\"comment\">         *  position = 0;</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] readBytes = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* 读取数据到bytes数组 */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = buffer.position(); i &lt; buffer.limit(); i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* 每读一次position + 1 */</span></span><br><span class=\"line\">            readBytes[i] = buffer.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * 清空Buffer</span></span><br><span class=\"line\"><span class=\"comment\">         * 此时为写模式：</span></span><br><span class=\"line\"><span class=\"comment\">         * capacity = limit = 1024</span></span><br><span class=\"line\"><span class=\"comment\">         * position = 0</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        buffer.clear();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 输出读取的数据</span></span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">new</span> String(readBytes, UTF_8));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配合图来讲解、图片还有内容部分来自互联网、可以看参考资料、  </p>\n<ol>\n<li><p>创建Buffer、<code>ByteBuffer buffer = ByteBuffer.allocate(1024)</code>就是创建一个的Buffer、假设创建的大小为10、那么position=0、capacity=10、limit=capacity<br><img src=\"http://assets.msyy233.com/20180831/104326811.png!blog\" alt=\"创建Buffer\"></p>\n</li>\n<li><p>Buffer写入、<code>buffer.put(strByte)</code>是像Buffer写入数据、每写入一个byte、position向前移动一个位、其实就是+1、如图是写入4个byte的状态<br><img src=\"http://assets.msyy233.com/20180831/1048132ae.png!blog\" alt=\"Buffer写入\"></p>\n</li>\n<li><p>模式切换、Buffer是分读写模式的、前面的概念也说的很清楚了、<code>buffer.flip()</code>表示切换模式、此时将limit置为position、position置为0、由于之前写入的模式、此时为读模式、<br><img src=\"http://assets.msyy233.com/20180831/105152a77.png!blog\" alt=\"模式切换\">  </p>\n<blockquote>\n<p>如果这个时候再切换到写模式、会续借着之前结束的位置写入、一旦写满只能调用clear()或compact()方法、clear()方法会清空整个缓冲区、compact()方法只会清除已经读过的数据、任何未读的数据都被移到缓冲区的起始处、新写入的数据将放到缓冲区未读数据的后面、  </p>\n</blockquote>\n</li>\n<li><p>读取数据、由于之前的模式切换了、position和limit之前就是可读的数据、<code>buffer.get()</code>每读取一个byte position+1、当position等于limit表示读取了所有数据、<br><img src=\"http://assets.msyy233.com/20180831/11063243c.png!blog\" alt=\"Buffer读取\"></p>\n</li>\n<li><p>清空Buffer、可以看步骤3的引用、调用clear()或compact()方法、这里只说调用clear方法的情况、顾名思义、清空整个Buffer、<br><img src=\"http://assets.msyy233.com/20180831/104326811.png!blog\" alt=\"创建Buffer\"></p>\n</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Buffer这边我看了比较多的资料所以介绍相对全面、主要功能也介绍完毕了、值得一提的是、buffer这边还有个mark相关的api没有介绍、不过我认为那并不重要、了解原理后能轻易的理解它们、</p>\n<h1 id=\"二、Channel\"><a href=\"#二、Channel\" class=\"headerlink\" title=\"二、Channel\"></a>二、Channel</h1><blockquote>\n<p>基本上、所有的IO在NIO中都从一个Channel开始、Channel有点象流、但Channel本身不能直接访问数据、Channel只能与Buffer进行交互、数据可以从Channel读到Buffer中、也可以从Buffer写到Channel中、Channel负责传输、Buffer负责存储、<br>Channel是访问IO服务的导管、通过Channel、我们可以以最小的开销来访问操作系统的IO服务、Buffer是Channel内部发送数据和接收数据的端点、这里有个图示：</p>\n<p><img src=\"http://assets.msyy233.com/20180725/140830c60.png!blog\" alt=\"Channel和Buffer\">   </p>\n</blockquote>\n<p>顺便说下、在标准的IO当中、都是基于字节流或字符流进行操作的、而在NIO中则是是基于Channel和Buffer进行操作、其中的Channel的虽然模拟了流的概念、实则大不相同、下面有个对比：</p>\n<table>\n<thead>\n<tr>\n<th>区别</th>\n<th>Stream</th>\n<th>Channel</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>支持异步</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>是否可双向传输数据</td>\n<td>不能，只能单向</td>\n<td>可以，既可以从通道读取数据，也可以向通道写入数据</td>\n</tr>\n<tr>\n<td>是否结合Buffer使用</td>\n<td>不</td>\n<td>必须结合Buffer使用</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>较低</td>\n<td>较高</td>\n</tr>\n</tbody></table>\n<h1 id=\"三、Selector\"><a href=\"#三、Selector\" class=\"headerlink\" title=\"三、Selector\"></a>三、Selector</h1><p>其中Selector就是复用器、用于管理多个通道（Channels）、Channel有点象流、基本上、所有的IO在NIO中都从一个Channel开始、数据可以从Channel读到Buffer中、也可以从Buffer 写到Channel中、这里有个图示：</p>\n<p><strong>不想写了、改天补</strong></p>\n<hr>\n<p><strong>参考资料：</strong><br><a href=\"https://www.cnblogs.com/pony1223/p/8179804.html\">通道（Channel）与缓冲区（Buffer）</a><br><a href=\"http://tutorials.jenkov.com/java-nio/index.html\">Java NIO系列教程</a>  </p>\n","categories":["io"],"tags":["nio","io","channel","buffer","selector","java"]},{"title":"JavaEE通过路径或域名获取资源","url":"/posts/29966.html","content":"<h2 id=\"一、通过路径\"><a href=\"#一、通过路径\" class=\"headerlink\" title=\"一、通过路径\"></a>一、通过路径</h2><h3 id=\"1、使用ServletContext\"><a href=\"#1、使用ServletContext\" class=\"headerlink\" title=\"1、使用ServletContext\"></a>1、使用ServletContext</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 这里将获取的path是web项目的全路径</span></span><br><span class=\"line\"><span class=\"comment\"> * 例如：E:/workspace/webapp/</span></span><br><span class=\"line\"><span class=\"comment\"> * webapp是我web项目的根目录</span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\">String path = servletContext.getRealPath(<span class=\"string\">&quot;/&quot;</span>);</span><br></pre></td></tr></table></figure>\n <span id=\"more\"></span>\n<h3 id=\"2、使用ClassLoader\"><a href=\"#2、使用ClassLoader\" class=\"headerlink\" title=\"2、使用ClassLoader\"></a>2、使用ClassLoader</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取Class对象</span></span><br><span class=\"line\">String clazz = getClass();</span><br><span class=\"line\"><span class=\"comment\">// 获取ClassLoader 对象</span></span><br><span class=\"line\">ClassLoader classLoader = clazz.getClassLoader();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过Class获取资源路径（相对路径当前Class目录）</span></span><br><span class=\"line\"><span class=\"comment\"> * 例如：%TOMCAT_HOME%/webapps/appName/WEB-INF/classes/com/accelerator/</span></span><br><span class=\"line\"><span class=\"comment\"> * 当前Class的包就是com.accelerator</span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\">URL url1 = clazz .getResource(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过ClassLoader获取资源路径（相对路径Class根目录）</span></span><br><span class=\"line\"><span class=\"comment\"> * 例如：%TOMCAT_HOME%/webapps/appName/WEB-INF/classes/</span></span><br><span class=\"line\"><span class=\"comment\"> * 当前Class的classpath根目录</span></span><br><span class=\"line\"><span class=\"comment\"> */</span> </span><br><span class=\"line\">URL url2 = classLoader.getResource(<span class=\"string\">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>此方法有个BUG（当文件路径有中文和空格时解析不正确）、提供以下解决方法：</strong></p>\n<ul>\n<li>使用<code>repaceAll(&quot;%20&quot;, &quot; &quot;)</code>替换后、只能解决空格问题、但是路径中包含%和中文就不行了、</li>\n<li>使用<code>URLDecoder.decode(String, &quot;UTF-8&quot;)</code>解码、但是只能解决一部分、若路径中含有+、也是不能解决的、原因是URL并不是完全用URLEncoder.encode(str,”UTF-8”)编码的、+号被解码后、却变成了空格</li>\n<li>可以解决所有的问题、用<code>getResource.toURI().getPath()</code>但是需要处理URISyntaxException异常、比较麻烦点、</li>\n</ul>\n</blockquote>\n<p><em>这个方法也可以不在Server环境里确定路径、两种getResource的方式最终实现都是通过classLoader、</em><br><strong>想深入了解的可以参考：</strong><a href=\"#\">classLoader.getResource(String)和class.getResource(String)的区别</a></p>\n<hr>\n<h2 id=\"二、通过域名\"><a href=\"#二、通过域名\" class=\"headerlink\" title=\"二、通过域名\"></a>二、通过域名</h2><h3 id=\"1、使用HttpServletRequest\"><a href=\"#1、使用HttpServletRequest\" class=\"headerlink\" title=\"1、使用HttpServletRequest\"></a>1、使用HttpServletRequest</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String path = request.getContextPath();</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * 这里获取的basePath为网站的根目录路径</span></span><br><span class=\"line\"><span class=\"comment\"> * 例如：http://www.accelerator.com:8080/test</span></span><br><span class=\"line\"><span class=\"comment\"> * test是我的项目context、</span></span><br><span class=\"line\"><span class=\"comment\"> * 此路径一般用来引用CSS、js、img等资源、</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">String basePath = request.getScheme() + <span class=\"string\">&quot;://&quot;</span> + request.getServerName() + <span class=\"string\">&quot;:&quot;</span></span><br><span class=\"line\">        + request.getServerPort() + path + <span class=\"string\">&quot;/&quot;</span>;</span><br></pre></td></tr></table></figure>\n","categories":["java"],"tags":["javaee路径","web项目根域名","类路径获取","Java资源路径"]},{"title":"Java不定长参数","url":"/posts/33024.html","content":"<p><em>在Java5中提供了不定长参数（varargs:variable number of arguments）、也就是在方法定义中可以使用个数不确定的参数、对于同一方法可以使用不同个数的参数调用、下面介绍如何定义不定长参数、以及如何使用不定长参数、</em></p>\n<hr>\n<h2 id=\"一、不定长参数的基本使用\"><a href=\"#一、不定长参数的基本使用\" class=\"headerlink\" title=\"一、不定长参数的基本使用\"></a>一、不定长参数的基本使用</h2><p><strong>定义实参个数可变的方法：只要在一个形参的类型与参数名之间加上三个连续的 “.”（即 “…”、英文里的句中省略号）、就可以让它和不确定个实参相匹配。</strong></p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** 不定长参数方法 */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sumvarargs</span><span class=\"params\">(<span class=\"keyword\">int</span>... intArrays)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; intArrays.length; i++) &#123;</span><br><span class=\"line\">            sum += intArrays[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用方式一</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum1 = sumvarargs(<span class=\"number\">10</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 调用方式二</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] varargs = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">10</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum2 = sumvarargs(varargs);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 输出结果 =&gt; sum1:35</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;sum1:%d%n&quot;</span>, sum1);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 输出结果 =&gt; sum2:35</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;sum2:%d%n&quot;</span>, sum2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>工作原理：</strong></p>\n<ol>\n<li>以调用方传递的参数的数目为长度创建一个数组、</li>\n<li>将实参的值放入数组中、</li>\n<li>将数组的引用传递给被调方法、</li>\n</ol>\n<p>Java源码使用例子：<code>String.format(String format, Object... args)</code></p>\n<hr>\n<h2 id=\"二、不定长参数问题和规范\"><a href=\"#二、不定长参数问题和规范\" class=\"headerlink\" title=\"二、不定长参数问题和规范\"></a>二、不定长参数问题和规范</h2><h3 id=\"1、调用问题和规范\"><a href=\"#1、调用问题和规范\" class=\"headerlink\" title=\"1、调用问题和规范\"></a>1、调用问题和规范</h3><ol>\n<li><p>如果调用的方法可以和两个可变参数匹配、则编译报错</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sumvarargs</span><span class=\"params\">(<span class=\"keyword\">int</span>... intArrays)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; intArrays.length; i++) &#123;</span><br><span class=\"line\">            sum += intArrays[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sumvarargs</span><span class=\"params\">(<span class=\"keyword\">int</span> intArray, <span class=\"keyword\">int</span>... intArrays)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = intArray;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; intArrays.length; i++) &#123;</span><br><span class=\"line\">            sum += intArrays[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">          下面两个调用都不能编译通过、</span></span><br><span class=\"line\"><span class=\"comment\">          因为编译器不知道该选哪个方法调用</span></span><br><span class=\"line\"><span class=\"comment\">          */</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum1 = sumvarargs(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum2 = sumvarargs(<span class=\"number\">10</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>);</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;sum:%d%n&quot;</span>, sum1);</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;sum:%d%n&quot;</span>, sum2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>如果调用可变长参数的重载方法时隐藏了实参类型、也可能发生类似问题一中错误、</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sumvarargs</span><span class=\"params\">(String desc, <span class=\"keyword\">int</span>... intArrays)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(desc);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (intArrays == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; intArrays.length; i++) &#123;</span><br><span class=\"line\">            sum += intArrays[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sumvarargs</span><span class=\"params\">(String desc, String... strArrays)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(desc);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (strArrays == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strArrays.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> intArray = Integer.valueOf(strArrays[i]);</span><br><span class=\"line\">            sum += intArray;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         下面两个调用都不能编译通过、</span></span><br><span class=\"line\"><span class=\"comment\">         因为编译器不知道该选哪个方法调用</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum1 = sumvarargs(<span class=\"string\">&quot;sum&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum2 = sumvarargs(<span class=\"string\">&quot;sum&quot;</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;sum1:%d%n&quot;</span>, sum1);</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;sum2:%d%n&quot;</span>, sum2);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> <strong>上面的情况是由于不是很好的编码习惯造成的、即调用者隐藏了实参类型、</strong><br> <strong>避免这种情况的代码写法如下：</strong></p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sumvarargs</span><span class=\"params\">(String desc, <span class=\"keyword\">int</span>... intArrays)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(desc);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (intArrays == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; intArrays.length; i++) &#123;</span><br><span class=\"line\">            sum += intArrays[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sumvarargs</span><span class=\"params\">(String desc, String... strArrays)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(desc);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (strArrays == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; strArrays.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> intArray = Integer.valueOf(strArrays[i]);</span><br><span class=\"line\">            sum += intArray;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 控制台输出：</span></span><br><span class=\"line\"><span class=\"comment\">     * 调用int不定长方法</span></span><br><span class=\"line\"><span class=\"comment\">     * 调用str不定长方法</span></span><br><span class=\"line\"><span class=\"comment\">     * sum1:0</span></span><br><span class=\"line\"><span class=\"comment\">     * sum2:3</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] intArrays = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum1 = sumvarargs(<span class=\"string\">&quot;调用int不定长方法&quot;</span>, intArrays);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum2 = sumvarargs(<span class=\"string\">&quot;调用str不定长方法&quot;</span>, <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;2&quot;</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;sum1:%d%n&quot;</span>, sum1);</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;sum2:%d%n&quot;</span>, sum2);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>调用的方法能够和固定参数的方法匹配、也能够与可变长参数的方法匹配、则选择固定参数的方法</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sumvarargs</span><span class=\"params\">(<span class=\"keyword\">int</span> intArray)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> intArray * <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sumvarargs</span><span class=\"params\">(<span class=\"keyword\">int</span>... intArrays)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; intArrays.length; i++) &#123;</span><br><span class=\"line\">            sum += intArrays[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum1 = sumvarargs(<span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum2 = sumvarargs(<span class=\"number\">10</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 输出结果 =&gt; sum1:20</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;sum1:%d%n&quot;</span>, sum1);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 输出结果 =&gt; sum2:35</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;sum2:%d%n&quot;</span>, sum2);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"2、定义问题和规范\"><a href=\"#2、定义问题和规范\" class=\"headerlink\" title=\"2、定义问题和规范\"></a>2、定义问题和规范</h3><ol>\n<li><p>一个方法只能有一个可变长参数、并且这个可变长参数必须是该方法的最后一个参数</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** 编译报错 */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(String... strs, List list)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** 编译报错 */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(String... strs, List... lists)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>重写变长方法也要循规蹈矩</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 向上转型</span></span><br><span class=\"line\">        Base base = <span class=\"keyword\">new</span> Sub();</span><br><span class=\"line\">        base.print(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 不转型</span></span><br><span class=\"line\">        Sub sub = <span class=\"keyword\">new</span> Sub();</span><br><span class=\"line\">        sub.print(<span class=\"string\">&quot;hello&quot;</span>); <span class=\"comment\">// 此行编译不通过</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(String... args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Base - args[0]：&quot;</span> + args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 子类，覆写父类方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title\">Base</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Sub - args[0]：&quot;</span> + args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一个能编译通过、这是为什么呢？事实上、Base对象把子类对象Sub做了向上转型、形参列表是由父类决定的、当然能通过、而看看子类直接调用的情况、这时编译器看到子类覆写了父类的print方法、因此肯定使用子类重新定义的print方法、尽管参数列表不匹配也不会跑到父类再去匹配下、因为找到了就不再找了、因此有了类型不匹配的错误、</p>\n<blockquote>\n<p>这是个特例、覆写的方法参数列表竟然可以与父类不相同、这违背了覆写的定义、并且会引发莫名其妙的错误、</p>\n<p><strong>总结下覆写必须满足的条件：</strong></p>\n<ol>\n<li>重写方法不能缩小访问权限</li>\n<li>参数列表必须与被重写方法相同（包括显示形式）</li>\n<li>返回类型必须与被重写方法的相同或是其子类</li>\n<li>重写方法不能抛出新的异常、或者超过了父类范围的异常、但是可以抛出更少、更有限的异常、或者不抛出异常</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<p><strong>参考资料：</strong><a href=\"http://www.cnblogs.com/lanxuezaipiao/p/3190673.html\">Java中可变长参数的使用及注意事项</a></p>\n","categories":["java"],"tags":["java","varargs"]},{"title":"Windows和Linux下JDK安装配置","url":"/posts/1678.html","content":"<h2 id=\"一、下载\"><a href=\"#一、下载\" class=\"headerlink\" title=\"一、下载\"></a>一、下载</h2><p><strong>官网下载地址：</strong><a href=\"http://www.oracle.com/technetwork/java/javase/archive-139210.html\">Oracle Java Archive</a></p>\n<p><em>根据需要下载相应JDK版本、系统版本和CPU位数</em></p>\n<h2 id=\"二、安装\"><a href=\"#二、安装\" class=\"headerlink\" title=\"二、安装\"></a>二、安装</h2><h3 id=\"1、Windows下JDK安装\"><a href=\"#1、Windows下JDK安装\" class=\"headerlink\" title=\"1、Windows下JDK安装\"></a>1、Windows下JDK安装</h3><span id=\"more\"></span>\n\n<p><img src=\"http://assets.msyy233.com/20180607/110510a2b.png!blog\" alt=\"jdk-8u101-windows-x64\"><br>本博文使用jdk-8u101-windows-x64安装包</p>\n<p><img src=\"http://assets.msyy233.com/20180607/110523c67.png!blog\" alt=\"安装核心简介\"><br>安装中各配置简介</p>\n<p>除了上图配置、其它直接无脑下一步完成就行</p>\n<h3 id=\"2、Linux下JDK安装\"><a href=\"#2、Linux下JDK安装\" class=\"headerlink\" title=\"2、Linux下JDK安装\"></a>2、Linux下JDK安装</h3><p>Linux个人推荐免安装版本、这里也使用免安装版本作为展示</p>\n<p>上传到/opt目录：<br><code>sftp&gt; cd /opt/ </code><br><code>sftp&gt; put -r &quot;C:\\Users\\Accelerator\\Downloads\\software\\jdk-8u101-linux-x64.tar.gz&quot;</code></p>\n<p>在opt目录解压：<br><code>[root@demo opt]# tar -xzvf jdk-8u101-linux-x64.tar.gz </code></p>\n<blockquote>\n<p>以上内容学过linux基础的都能懂、没学过建议先学习一下linux基本知识、<br>因为使用免安装版本所以解压就安装完成了、<br>yum安装openjdk有兴趣可以找找其他教程、但是个人提倡免安装的、</p>\n</blockquote>\n<h2 id=\"三、配置\"><a href=\"#三、配置\" class=\"headerlink\" title=\"三、配置\"></a>三、配置</h2><h3 id=\"1、Windows下JDK配置\"><a href=\"#1、Windows下JDK配置\" class=\"headerlink\" title=\"1、Windows下JDK配置\"></a>1、Windows下JDK配置</h3><p>我的电脑右键属性 -&gt; 高级系统设置 -&gt; 环境变量<br><img src=\"http://assets.msyy233.com/20180607/110536333.png!blog\" alt=\"环境变量_1\"></p>\n<p>点击新建按钮、配置Java安装目录、如图：<br><img src=\"http://assets.msyy233.com/20180607/1105512af.png!blog\" alt=\"环境变量_2\"></p>\n<p>配置PATH、选中PATH、点编辑、开始位置添加 <code>%JAVA_HOME%\\bin;</code> 即可<br><img src=\"http://assets.msyy233.com/20180607/1106064c4.png!blog\" alt=\"环境变量_3\"></p>\n<blockquote>\n<p>从JDK版本1.6开始默认CLASS_PATH就不需要配置。</p>\n</blockquote>\n<h3 id=\"2、Linux下JDK配置\"><a href=\"#2、Linux下JDK配置\" class=\"headerlink\" title=\"2、Linux下JDK配置\"></a>2、Linux下JDK配置</h3><p>Linux JDK环境变量配置、这里选用基于用户的环境变量</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@demo ~]<span class=\"comment\"># cd ~</span></span><br><span class=\"line\">[root@demo ~]<span class=\"comment\"># vim .bash_profile</span></span><br><span class=\"line\">[root@demo ~]<span class=\"comment\"># source .bash_profile</span></span><br><span class=\"line\">[root@demo ~]<span class=\"comment\"># java -version</span></span><br></pre></td></tr></table></figure>\n\n<p>.bash_profile添加红框部分内容<br><img src=\"http://assets.msyy233.com/20180607/110621653.png!blog\" alt=\"环境变量_4\"></p>\n<p>如图所示、配置完成<br><img src=\"http://assets.msyy233.com/20180607/11062900b.png!blog\" alt=\"环境变量_5\"></p>\n","categories":["java"],"tags":["java"]},{"title":"Oracle11gR2 Centos6.x静默安装","url":"/posts/28521.html","content":"<p>本文资料来源：<br><a href=\"http://docs.oracle.com/cd/E11882_01/install.112/e24326/toc.htm\">Oracle® Database Quick Installation Guide（linux_x64）</a><br><a href=\"http://docs.oracle.com/cd/E11882_01/install.112/e24324/toc.htm\">Oracle® Database Quick Installation Guide（linux_x86）</a></p>\n<h2 id=\"一、下载\"><a href=\"#一、下载\" class=\"headerlink\" title=\"一、下载\"></a>一、下载</h2><p>下载地址：<a href=\"http://www.oracle.com/technetwork/database/enterprise-edition/downloads/index.html\">Oracle Database Software Downloads</a><br><img src=\"http://assets.msyy233.com/20180726/095340854.png!blog\" alt=\"Oracle许可证\">    </p>\n<span id=\"more\"></span>\n<p><img src=\"http://assets.msyy233.com/20180726/095616767.png!blog\" alt=\"Oracle11gR2\"><br>第一张图勾选圈出的选项同意许可证协议、第二张图选择正确的版本下载（注意是11gR2的Linux版本）、</p>\n<h2 id=\"二、准备\"><a href=\"#二、准备\" class=\"headerlink\" title=\"二、准备\"></a>二、准备</h2><h3 id=\"（一）内存空间\"><a href=\"#（一）内存空间\" class=\"headerlink\" title=\"（一）内存空间\"></a>（一）内存空间</h3><p>安装Oracle11gR2实例必须满足：<br><strong>最小：</strong> 1 GB内存<br><strong>建议：</strong> 2GB内存或更多  </p>\n<p>查询内存命令：<code>grep MemTotal /proc/meminfo</code> 也可以用<code>free</code>或<code>top</code>  </p>\n<p>建议用以下表格关系来根据内存大小配置交换空间大小  </p>\n<table>\n<thead>\n<tr>\n<th>有效内存</th>\n<th>交换分区</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1GB到2GB之间</td>\n<td>1.5倍内存大小</td>\n</tr>\n<tr>\n<td>2GB到16GB之间</td>\n<td>等于内存大小</td>\n</tr>\n<tr>\n<td>超过16GB</td>\n<td>16 GB</td>\n</tr>\n</tbody></table>\n<h3 id=\"（一）磁盘空间\"><a href=\"#（一）磁盘空间\" class=\"headerlink\" title=\"（一）磁盘空间\"></a>（一）磁盘空间</h3><p>安装分区5G以上（不包含数据文件）、详情参照表格、<code>/tmp</code>文件夹至少1GB空闲空间  </p>\n<table>\n<thead>\n<tr>\n<th>安装版本</th>\n<th>软件大小</th>\n<th>数据大小</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Enterprise Edition</td>\n<td>4.7 GB</td>\n<td>1.7 GB</td>\n</tr>\n<tr>\n<td>Standard Edition</td>\n<td>4.6 GB</td>\n<td>1.5 GB</td>\n</tr>\n</tbody></table>\n<h2 id=\"三、安装\"><a href=\"#三、安装\" class=\"headerlink\" title=\"三、安装\"></a>三、安装</h2><ol>\n<li><p>依赖包安装 —— <span style=\"color:red\"><strong>root用户操作</strong></span>（以下安装包为个人整理） </p>\n<ul>\n<li>Centos6.x 32位所需安装包：<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 32位系统只会安装i686包</span></span><br><span class=\"line\">yum -y install binutils compat-libcap1 compat-libstdc++-33 gcc gcc-c++ \\</span><br><span class=\"line\">glibc glibc-devel ksh libgcc libstdc++ libstdc++-devel libaio \\</span><br><span class=\"line\">libaio-devel make sysstat unixODBC unixODBC-devel elfutils-libelf-devel</span><br></pre></td></tr></table></figure></li>\n<li>Centos6.x 64位所需安装包<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 64位系统需要x86_64包</span></span><br><span class=\"line\">yum -y install gcc.x86_64 make.x86_64 binutils.x86_64 glibc.x86_64 \\</span><br><span class=\"line\">compat-libstdc++-33.x86_64 elfutils-libelf.x86_64 \\</span><br><span class=\"line\">elfutils-libelf-devel.x86_64 glibc-common.x86_64 glibc-devel.x86_64 \\</span><br><span class=\"line\">glibc-headers.x86_64 gcc-c++.x86_64 libaio-devel.x86_64 libgcc.x86_64 \\</span><br><span class=\"line\">libstdc++.x86_64 libstdc++-devel.x86_64 sysstat.x86_64 unixODBC.x86_64 \\</span><br><span class=\"line\">unixODBC-devel.x86_64 expat.x86_64 ksh.x86_64</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 64位系统需要i686包</span></span><br><span class=\"line\">yum -y install libaio.i686 glibc.i686 compat-libstdc++-33.i686 \\</span><br><span class=\"line\">elfutils-libelf.i686 elfutils-libelf-devel.i686 libaio-devel.i686 \\</span><br><span class=\"line\">libgcc.i686 libstdc++.i686 unixODBC.i686 unixODBC-devel.i686</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>Oracle用户创建 —— <span style=\"color:red\"><strong>root用户操作</strong></span></p>\n<ul>\n<li>创建Oracle 安装用户组：<code>/usr/sbin/groupadd oinstall</code></li>\n<li>创建Oracle DBA用户组：<code>/usr/sbin/groupadd dba</code></li>\n<li>创建Oracle 用户：<code>/usr/sbin/useradd -g oinstall -G dba oracle</code></li>\n<li>设置Oracle 用户密码：<code>passwd oracle</code>  </li>\n</ul>\n</li>\n<li><p>系统参数配置 —— <span style=\"color:red\"><strong>root用户操作</strong></span></p>\n<ul>\n<li>打开<code>vi /etc/sysctl.conf</code>添加以下参数配置（官网给的最小配置）：<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">fs.aio-max-nr</span> = <span class=\"number\">1048576</span></span><br><span class=\"line\"><span class=\"attr\">fs.file-max</span> = <span class=\"number\">6815744</span></span><br><span class=\"line\"><span class=\"attr\">kernel.shmall</span> = <span class=\"number\">2097152</span></span><br><span class=\"line\"><span class=\"attr\">kernel.shmmax</span> = <span class=\"number\">536870912</span></span><br><span class=\"line\"><span class=\"attr\">kernel.shmmni</span> = <span class=\"number\">4096</span></span><br><span class=\"line\"><span class=\"attr\">kernel.sem</span> = <span class=\"number\">250</span> <span class=\"number\">32000</span> <span class=\"number\">100</span> <span class=\"number\">128</span></span><br><span class=\"line\"><span class=\"attr\">net.ipv4.ip_local_port_range</span> = <span class=\"number\">9000</span> <span class=\"number\">65500</span></span><br><span class=\"line\"><span class=\"attr\">net.core.rmem_default</span> = <span class=\"number\">262144</span></span><br><span class=\"line\"><span class=\"attr\">net.core.rmem_max</span> = <span class=\"number\">4194304</span></span><br><span class=\"line\"><span class=\"attr\">net.core.wmem_default</span> = <span class=\"number\">262144</span></span><br><span class=\"line\"><span class=\"attr\">net.core.wmem_max</span> = <span class=\"number\">1048576</span></span><br></pre></td></tr></table></figure></li>\n<li>修改完成后执行<code>/sbin/sysctl -p</code>使配置立即生效</li>\n</ul>\n</li>\n<li><p>Oracle用户限制 —— <span style=\"color:red\"><strong>root用户操作</strong></span></p>\n<ul>\n<li>打开<code>vi /etc/security/limits.conf</code>添加以下参数配置（官网给的最小配置）：<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">oracle          soft    nofile          1024</span><br><span class=\"line\">oracle          hard    nofile          65536</span><br><span class=\"line\">oracle          soft    nproc           2047</span><br><span class=\"line\">oracle          hard    nproc           16384</span><br><span class=\"line\">oracle          soft    stack           10240</span><br><span class=\"line\">oracle          hard    stack           32768</span><br></pre></td></tr></table></figure></li>\n<li>修改完成后重新登录oracle用户查看是否生效（参考官网-如下图：）<br><img src=\"http://assets.msyy233.com/20210310/1718302ad.png!blog\" alt=\"官网用户权限相关\"></li>\n</ul>\n</li>\n<li><p>创建安装目录与权限 ——  <font color='red'><strong>root用户操作</strong></font></p>\n<ul>\n<li>创建安装目录：<code>mkdir -p /u01/app/</code></li>\n<li>修改安装目录所属用户和组：<code>chown -R oracle:oinstall /u01/app/</code></li>\n<li>修改安装目录权限：<code>chmod -R 775 /u01/app/</code></li>\n</ul>\n</li>\n<li><p>安装Oracle数据库软件 —— <font color='red'><strong>oracle用户操作</strong></font></p>\n<ul>\n<li>解压Oracle数据库软件压缩文件<code>unzip ~/linux.x64_11gR2_database_1of2.zip &amp;&amp; unzip ~/linux.x64_11gR2_database_1of2.zip</code></li>\n<li>打开<code>vi ~/.bash_profile</code>添加以下安装所需环境变量：<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ORACLE_BASE=/u01/app/oracle</span><br><span class=\"line\">ORACLE_SID=orcl</span><br><span class=\"line\"><span class=\"built_in\">export</span> ORACLE_BASE ORACLE_SID</span><br></pre></td></tr></table></figure></li>\n<li>编辑静默安装模板文件（软件相关配置）、模板文件在解压后的目录下<code>database/response/db_install.rsp</code>、<a href=\"http://blog.chinaunix.net/uid-23886490-id-3565908.html\">模板文件的详解</a>参考其他的博客吧、这里不再详细说明</li>\n<li>执行安装 <code>~/database/runInstaller -silent -force -responseFile ~/database/response/db_install.rsp</code></li>\n</ul>\n</li>\n<li><p>执行清单权限相关脚本 ——  <font color='red'><strong>root用户操作</strong></font></p>\n<ul>\n<li>运行 <code>/u01/app/oraInventory/orainstRoot.sh &amp;&amp; /u01/app/oracle/product/11.2.0/dbhome_1/root.sh</code><blockquote>\n<p>orainstRoot.sh：设置产品目录位置与拥有该目录的操作系统组、并产生/etc/oraInst.loc<br>root.sh：用来设置必要的操作系统权限、并将orahome、oraenv、coraenv复制到/usr/local/bin目录下、生成/etc/oratab、其中存放一些数据库相关信息</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>配置Oracle数据库 ——  <font color='red'><strong>oracle用户操作</strong></font></p>\n<ul>\n<li><p>打开<code>vi ~/.bash_profile</code>添加以下软件所需环境变量：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ORACLE_HOME=<span class=\"variable\">$ORACLE_BASE</span>/product/11.2.0/dbhome_1</span><br><span class=\"line\">TNS_ADMIN=<span class=\"variable\">$ORACLE_HOME</span>/network/admin</span><br><span class=\"line\">PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$ORACLE_HOME</span>/bin</span><br><span class=\"line\">LD_LIBRARY_PATH=<span class=\"variable\">$LD_LIBRARY_PATH</span>:<span class=\"variable\">$ORACLE_HOME</span>/lib:/lib:/usr/lib:/usr/<span class=\"built_in\">local</span>/lib</span><br><span class=\"line\">CLASSPATH=<span class=\"variable\">$CLASSPATH</span>:<span class=\"variable\">$ORACLE_HOME</span>/jlib:<span class=\"variable\">$ORACLE_HOME</span>/rdbms/jlib:<span class=\"variable\">$ORACLE_HOME</span>/network/jlib:<span class=\"variable\">$ORACLE_HOME</span>/lib:<span class=\"variable\">$ORACLE_HOME</span>/ctx/lib</span><br><span class=\"line\">ORACLE_OWNER=oracle</span><br><span class=\"line\">SPFILE_PATH=<span class=\"variable\">$ORACLE_HOME</span>/dbs</span><br><span class=\"line\">ORA_NLS10=<span class=\"variable\">$ORACLE_HOME</span>/nls/data</span><br><span class=\"line\"><span class=\"built_in\">export</span> ORACLE_HOME TNS_ADMIN PATH LD_LIBRARY_PATH CLASSPATH ORACLE_OWNER SPFILE_PATH ORA_NLS10</span><br></pre></td></tr></table></figure></li>\n<li><p>配置监听 <code>$ORACLE_HOME/bin/netca /silent /responseFile ~/database/response/netca.rsp</code></p>\n</li>\n<li><p>编辑数据库实例模板文件（<em>实例相关配置</em>）、模板文件在解压后的目录下<code>database/response/dbca.rsp</code>、<a href=\"http://blog.csdn.net/yinzhipeng123/article/details/53144589\">模板文件的详解</a>参考其他的博客吧、这里不再详细说明</p>\n</li>\n<li><p>创建实例 <code>$ORACLE_HOME/bin/dbca -silent -responseFile ~/database/response/dbca.rsp</code></p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"四、配置\"><a href=\"#四、配置\" class=\"headerlink\" title=\"四、配置\"></a>四、配置</h2><h3 id=\"（一）自启动\"><a href=\"#（一）自启动\" class=\"headerlink\" title=\"（一）自启动\"></a>（一）自启动</h3><ol>\n<li><p>修改vi /etc/oratab ——  <font color='red'><strong>root用户操作</strong></font></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># This file is used by ORACLE utilities.  It is created by root.sh</span></span><br><span class=\"line\"><span class=\"comment\"># and updated by the Database Configuration Assistant when creating</span></span><br><span class=\"line\"><span class=\"comment\"># a database.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># A colon, &#x27;:&#x27;, is used as the field terminator.  A new line terminates</span></span><br><span class=\"line\"><span class=\"comment\"># the entry.  Lines beginning with a pound sign, &#x27;#&#x27;, are comments.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Entries are of the form:</span></span><br><span class=\"line\"><span class=\"comment\">#   $ORACLE_SID:$ORACLE_HOME:&lt;N|Y&gt;:</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># The first and second fields are the system identifier and home</span></span><br><span class=\"line\"><span class=\"comment\"># directory of the database respectively.  The third filed indicates</span></span><br><span class=\"line\"><span class=\"comment\"># to the dbstart utility that the database should , &quot;Y&quot;, or should not,</span></span><br><span class=\"line\"><span class=\"comment\"># &quot;N&quot;, be brought up at system boot time.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># Multiple entries with the same $ORACLE_SID are not allowed.</span></span><br><span class=\"line\"><span class=\"comment\">#</span></span><br><span class=\"line\"><span class=\"comment\"># 改变此处N为Y</span></span><br><span class=\"line\">MFGS:/u01/app/oracle/product/11.2.0/dbhome_1:Y</span><br></pre></td></tr></table></figure></li>\n<li><p>配置自启动脚本 ——  <font color='red'><strong>root用户操作</strong></font></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\">  <span class=\"comment\">#chkconfig: 345 91 91</span></span><br><span class=\"line\">  <span class=\"comment\">#description: oracle autorun services</span></span><br><span class=\"line\">  <span class=\"comment\">#/etc/init.d/oracle</span></span><br><span class=\"line\">  <span class=\"comment\">#</span></span><br><span class=\"line\">  <span class=\"comment\">#Run-level Stratup script for the Oracle Instance, Listener, and Web Interface</span></span><br><span class=\"line\"></span><br><span class=\"line\">  AUTO_FILE_NAME=oracle</span><br><span class=\"line\">  <span class=\"built_in\">export</span> ORACLE_BASE=/u01/app/oracle</span><br><span class=\"line\">  <span class=\"built_in\">export</span> ORACLE_HOME=<span class=\"variable\">$ORACLE_BASE</span>/product/11.2.0/dbhome_1</span><br><span class=\"line\">  <span class=\"built_in\">export</span> ORACLE_SID=orcl</span><br><span class=\"line\">  <span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$ORACLE_HOME</span>/bin</span><br><span class=\"line\">   </span><br><span class=\"line\">  ORA_OWNR=<span class=\"string\">&quot;oracle&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    start)</span><br><span class=\"line\">        su <span class=\"variable\">$ORA_OWNR</span> -lc <span class=\"variable\">$ORACLE_HOME</span>/bin/dbstart</span><br><span class=\"line\">        touch /var/lock/subsys/<span class=\"variable\">$AUTO_FILE_NAME</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Oracle Start Successful!&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    stop)</span><br><span class=\"line\">        su <span class=\"variable\">$ORA_OWNR</span> -lc <span class=\"variable\">$ORACLE_HOME</span>/bin/dbshut</span><br><span class=\"line\">  \trm -f /var/lock/subsys/<span class=\"variable\">$AUTO_FILE_NAME</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Oracle Stop Successful!&quot;</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    reload|restart)</span><br><span class=\"line\">        <span class=\"variable\">$0</span> stop</span><br><span class=\"line\">        <span class=\"variable\">$0</span> start</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    *)</span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Usage: `basename <span class=\"variable\">$0</span>` &#123;start|stop|reload|restart&#125;&quot;</span></span><br><span class=\"line\">        <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\">  <span class=\"keyword\">esac</span></span><br><span class=\"line\">  <span class=\"built_in\">exit</span> 0</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">#chmod 755 /etc/init.d/oracle</span></span><br><span class=\"line\">  <span class=\"comment\">#chkconfig --add oracle</span></span><br><span class=\"line\">  <span class=\"comment\">#chkconfig --list oracle</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"五、完成\"><a href=\"#五、完成\" class=\"headerlink\" title=\"五、完成\"></a>五、完成</h2>","categories":["oracle"],"tags":["oracle","静默安装"]},{"title":"Maven Nexus OSS 2.xx 教程","url":"/posts/9116.html","content":"<p>本文资料来源：<a href=\"http://books.sonatype.com/nexus-book/reference/index.html\">Nexus Documentation - Nexus Repository Manager 2.14</a></p>\n<h2 id=\"一、Nexus的下载和部署\"><a href=\"#一、Nexus的下载和部署\" class=\"headerlink\" title=\"一、Nexus的下载和部署\"></a>一、Nexus的下载和部署</h2><h3 id=\"1、Nexus下载\"><a href=\"#1、Nexus下载\" class=\"headerlink\" title=\"1、Nexus下载\"></a>1、Nexus下载</h3><p><strong>官方下载地址：</strong><a href=\"https://www.sonatype.com/download-oss-sonatype\">Download Nexus Repository OSS</a></p>\n<p><em>注意选择Nexus2.xx版本，本教程是基于Nexus2.xx。</em><br><strong>如需要Nexus3.xx教程请移步：</strong><a href=\"#\">Maven Nexus OSS 3.xx 教程（有时间写）</a></p>\n<h3 id=\"2、Nexus部署和配置\"><a href=\"#2、Nexus部署和配置\" class=\"headerlink\" title=\"2、Nexus部署和配置\"></a>2、Nexus部署和配置</h3><h4 id=\"配置JDK\"><a href=\"#配置JDK\" class=\"headerlink\" title=\"配置JDK\"></a>配置JDK</h4><p><strong>参考：</strong><a href=\"http://www.msyy233.com/posts/1678.html\">JDK配置教程</a>  </p>\n<blockquote>\n<p>如果上面教程看不明白可以谷歌或者百度一下、类似有很多<br>入门教程不做详细讲解</p>\n</blockquote>\n<span id=\"more\"></span>\n<h4 id=\"配置简介\"><a href=\"#配置简介\" class=\"headerlink\" title=\"配置简介\"></a>配置简介</h4><p>解压后有两个目录：  </p>\n<blockquote>\n<p>nexus-2.14.1-01：nexus服务主目录（真正的nexus项目）<br>sonatype-work：nexus工作空间（定时任务、用户配置、下载资源）  </p>\n</blockquote>\n<p><code>nexus-2.14.1-01/bin/jsw/conf/wrapper.conf</code> 是基础参数配置、<br>例如：指定java执行命令、jvm参数添加、日志级别和文件等其他配置、下面是示例  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">set.JAVA_HOME=/opt/jdk1.8.0_111/</span><br><span class=\"line\">wrapper.java.command=%JAVA_HOME%/bin/java</span><br><span class=\"line\">wrapper.java.maxmemory=2000</span><br></pre></td></tr></table></figure>\n\n<p><code>nexus-2.14.1-01/conf/</code>目录下是nexus服务参数配置<br><code>nexus-2.14.1-01/conf/nexus.properties</code>中可以配置ContextPath和端口号<br>例如：jetty服务配置、logback日志配置、ContextPath和端口号配置等  </p>\n<h4 id=\"Windows环境\"><a href=\"#Windows环境\" class=\"headerlink\" title=\"Windows环境\"></a>Windows环境</h4><p>进入<code>nexus-2.14.1-01/bin</code>目录下、nexus支持命令如下、<br><code>Usage: nexus &#123; console : start : stop : restart : install : uninstall &#125;</code>  </p>\n<p><strong>console：</strong>控制台启动（退出脚本停止运行）<br><strong>start：</strong>服务启动（后台运行）<br><strong>stop：</strong>服务停止（停下后台进程）<br><strong>restart：</strong>重启服务<br><strong>install：</strong>安装服务<br><strong>uninstall：</strong>卸载服务  </p>\n<h4 id=\"Linux环境\"><a href=\"#Linux环境\" class=\"headerlink\" title=\"Linux环境\"></a>Linux环境</h4><p>进入<code>nexus-2.14.1-01/bin</code>目录下、nexus支持命令如下、<br><code>Usage: ./nexus &#123; console | start | stop | restart | status | dump &#125;</code><br><strong>console：</strong>控制台启动（退出脚本停止运行）<br><strong>start：</strong>服务启动（后台运行）<br><strong>stop：</strong>服务停止（停下后台进程）<br><strong>restart：</strong>重启服务<br><strong>status：</strong>输出运行状态（主要是PID）  </p>\n<p><strong>dump：</strong>做了一步正常停止进程的操作、博主也不清楚有啥用<br>希望谁知道评论留言、博主会及时更正、<br>下面是脚本内容：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">dump</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Dumping <span class=\"variable\">$APP_LONG_NAME</span>...&quot;</span></span><br><span class=\"line\">    getpid</span><br><span class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"string\">&quot;X<span class=\"variable\">$pid</span>&quot;</span> = <span class=\"string\">&quot;X&quot;</span> ]</span><br><span class=\"line\">    <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"built_in\">echo</span> <span class=\"string\">&quot;<span class=\"variable\">$APP_LONG_NAME</span> was not running.&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">kill</span> -3 <span class=\"variable\">$pid</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> [ $? -ne 0 ]</span><br><span class=\"line\">        <span class=\"keyword\">then</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Failed to dump <span class=\"variable\">$APP_LONG_NAME</span>.&quot;</span></span><br><span class=\"line\">            <span class=\"built_in\">exit</span> 1</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Dumped <span class=\"variable\">$APP_LONG_NAME</span>.&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">fi</span></span><br><span class=\"line\">    <span class=\"keyword\">fi</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Linux配置服务方式\"><a href=\"#Linux配置服务方式\" class=\"headerlink\" title=\"Linux配置服务方式\"></a>Linux配置服务方式</h5><p><strong>官方提供方法（<a href=\"http://books.sonatype.com/nexus-book/reference/install-sect-service.html#_running_as_a_service_on_linux\">文档地址</a>）：</strong></p>\n<ol>\n<li><p>创建nexus用户用来运行服务</p>\n</li>\n<li><p>复制<code>$NEXUS_HOME/bin/nexus</code>到<code>/etc/init.d/nexus</code></p>\n</li>\n<li><p>修改<code>/etc/init.d/nexus</code>权限和所属用户为root</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod 755 /etc/init.d/nexus</span><br><span class=\"line\">chown root /etc/init.d/nexus</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编辑脚本 </p>\n<ol>\n<li>NEXUS_HOME为真实nexus的绝对路径、</li>\n<li>设置RUN_AS_USER为nexus</li>\n<li>修改PIDDIR到一个nexus有读写权限的用户、大多数linux系统<code>/var/run</code>只有root用户有权限、配置位置wrapper.pidfile、更多wrapper.conf配置请参考<a href=\"http://wrapper.tanukisoftware.com/doc/english/properties.html\">官方文档</a></li>\n<li>修改sonatype-work包括子目录所属nexus用户和其用户组</li>\n<li>配置Java环境变量</li>\n</ol>\n</li>\n<li><p>添加服务和自启动</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">chkconfig --add nexus</span><br><span class=\"line\">chkconfig --level 345 nexus on</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><strong>基于官方方法优化：</strong></p>\n<ol>\n<li><p>创建nexus用户用来运行服务</p>\n</li>\n<li><p>创建软连接<code>$NEXUS_HOME/bin/nexus</code>到<code>/etc/init.d/nexus</code></p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ln -s <span class=\"variable\">$NEXUS_HOME</span>/bin/nexus /etc/init.d/nexus</span><br></pre></td></tr></table></figure></li>\n<li><p>修改<code>/etc/init.d/nexus</code>权限和所属用户为root</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod 755 /etc/init.d/nexus</span><br><span class=\"line\">chown root /etc/init.d/nexus</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编辑脚本</p>\n<ol>\n<li>设置RUN_AS_USER为nexus</li>\n<li>修改PIDDIR到一个nexus有读写权限的用户、大多数linux系统<code>/var/run</code>只有root用户有权限、配置位置wrapper.pidfile、更多wrapper.conf配置请参考<a href=\"http://wrapper.tanukisoftware.com/doc/english/properties.html\">官方文档</a></li>\n<li>修改sonatype-work包括子目录所属nexus用户和其用户组</li>\n<li>配置Java环境变量</li>\n</ol>\n</li>\n<li><p>添加服务和自启动</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">chkconfig --add nexus</span><br><span class=\"line\">chkconfig --level 345 nexus on</span><br></pre></td></tr></table></figure></li>\n</ol>\n<blockquote>\n<p>主要优化了复制脚本这一步、本人用的没啥问题、如果这样做有问题欢迎小伙伴指出</p>\n</blockquote>\n<h2 id=\"二、Nexus的配置和使用\"><a href=\"#二、Nexus的配置和使用\" class=\"headerlink\" title=\"二、Nexus的配置和使用\"></a>二、Nexus的配置和使用</h2><h3 id=\"1、整体介绍\"><a href=\"#1、整体介绍\" class=\"headerlink\" title=\"1、整体介绍\"></a>1、整体介绍</h3><p>启动nexus服务后、打开首页（<a href=\"http://localhost:8081/nexus\">http://localhost:8081/nexus</a>）<br><img src=\"http://assets.msyy233.com/20180719/1350523ce.png!blog\" alt=\"Nexus服务首页\">  </p>\n<p>点开查看仓库、默认已经配置了一些仓库<br><img src=\"http://assets.msyy233.com/20180719/135159123.png!blog\" alt=\"Nexus默认仓库\">  </p>\n<h4 id=\"仓库简介\"><a href=\"#仓库简介\" class=\"headerlink\" title=\"仓库简介\"></a>仓库简介</h4><ol>\n<li>Public Repositories：仓库组</li>\n<li>3rd party：一般自己上传无法从公共仓库获得的第三方发布版本的依赖包、例如oracle的ojdbc等、  </li>\n<li>Apache Snapshots：用了代理ApacheMaven仓库快照版本的构件仓库、一般不使用  </li>\n<li>Central：用来代理maven中央仓库中发布版本构件的仓库  </li>\n<li>Central M1 shadow：用于提供中央仓库中M1格式的发布版本的构件镜像仓库  </li>\n<li>Releases：用来部署管理内部的发布版本构件的宿主类型仓库  </li>\n<li>Snapshots：用来部署管理内部的快照版本构件的宿主类型仓库  </li>\n</ol>\n<h4 id=\"仓库类型\"><a href=\"#仓库类型\" class=\"headerlink\" title=\"仓库类型\"></a>仓库类型</h4><ol>\n<li>group：仓库组、仓库组的意思是将多个仓库整合、Public Repositories默认整合了4个仓库Releases、Snapshots、3rd party和Central、功能上展现就是在Releases中找你的依赖包、找到就不往下找了、找不到就到Snapshots中找、依此类推、  </li>\n<li>hosted：宿主、宿主简单的说就是自己的仓库、自己的包、自己上次、自己管理  </li>\n<li>proxy：代理、代理仓库是模拟某个远程仓库、使用时先将远程仓库的依赖包下载到nexus服务器、然后在通过nexus服务器下载到本地库、众所周知maven中央库速度很慢、公司开发团队通过这个方式就可以很好的节约带宽  </li>\n<li>virtual：虚拟、我也不知道有什么用、到目前为止我都没用过  </li>\n</ol>\n<h4 id=\"仓库策略\"><a href=\"#仓库策略\" class=\"headerlink\" title=\"仓库策略\"></a>仓库策略</h4><p>在使用maven过程中、我们在开发阶段经常性的会有很多公共库处于不稳定状态、随时需要修改并发布、可能一天就要发布一次、遇到bug时、甚至一天要发布N次、我们知道、maven的依赖管理是基于版本管理的、对于发布状态的artifact、如果版本号相同、即使我们内部的镜像服务器上的组件比本地新、maven也不会主动下载的、如果我们在开发阶段都是基于正式发布版本来做依赖管理、那么遇到这个问题、就需要升级组件的版本号、可这样就明显不符合要求和实际情况了、但是、如果是基于快照版本、那么问题就自热而然的解决了、而maven已经为我们准备好了这一切、<br>maven中的仓库策略分为两种、snapshot快照仓库和release发布仓库、snapshot快照仓库用于保存开发过程中的不稳定版本、release正式仓库则是用来保存稳定的发行版本、定义一个组件/模块为快照版本、只需要在pom文件中在该模块的版本号后加上-SNAPSHOT即可（注意这里必须是大写）、如下：  </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.accelerator<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>demo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>maven2会根据模块的版本号（pom文件中的version）中是否带有-SNAPSHOT来判断是快照版本还是正式版本、如果是快照版本、那么在mvn deploy时会自动发布到快照版本库中、而使用快照版本的模块、在不更改版本号的情况下、直接编译打包时、maven会自动从镜像服务器上下载最新的快照版本、如果是正式发布版本、那么在mvn deploy时会自动发布到正式版本库中、而使用正式版本的模块、在不更改版本号的情况下、编译打包时如果本地已经存在该版本的模块则不会主动去镜像服务器上下载、</p>\n<h3 id=\"2、配置说明\"><a href=\"#2、配置说明\" class=\"headerlink\" title=\"2、配置说明\"></a>2、配置说明</h3><p>感觉这个还真没啥说明的、简单说说~首先以管理员身份登录、默认用户名/密码（admin/admin123）、可以改、登录成功后、多了一些菜单和功能、有些配置我从来没用过、感觉实际生产中也应该用不着、<br>这里就只介绍简单的仓库配置、</p>\n<h4 id=\"仓库组配置\"><a href=\"#仓库组配置\" class=\"headerlink\" title=\"仓库组配置\"></a>仓库组配置</h4><p><img src=\"http://assets.msyy233.com/20180719/1352479a2.png!blog\" alt=\"仓库组配置\"><br>点开仓库组、可以看到登录后有了configuration选项卡、这里看看就明白了吧~<br>左边整合的仓库排序、右边可以使用的仓库、<br>Group ID：仓库唯一ID<br>Group Name：仓库名称<br>Provider：适配仓库格式<br>Format：是根据上面来的<br>Publish URL：就当时开启仓库组的开关吧</p>\n<h4 id=\"宿主仓库配置\"><a href=\"#宿主仓库配置\" class=\"headerlink\" title=\"宿主仓库配置\"></a>宿主仓库配置</h4><p><img src=\"http://assets.msyy233.com/20180719/1353193e4.png!blog\" alt=\"宿主仓库配置\"><br>已经说过的就不重复了、这里说一下没说过的几个配置<br>Repository Policy：这个就是仓库策略、可以看前面、说的很清楚<br>Default Local Storage Location：默认依赖包存放位置<br>Override Local Storage Location：重写依赖包存放位置<br>Deployment Policy：发布策略、是否允许重新发布、只读、作用可以联想一下Repository Policy配置<br>Allow File Browsing：是否允许浏览器中以文件管理方式浏览<br>Include in Search：包含在搜索中<br>Not Found Cache TTL：当包找不到的时候、多久再次查找</p>\n<h4 id=\"代理仓库配置\"><a href=\"#代理仓库配置\" class=\"headerlink\" title=\"代理仓库配置\"></a>代理仓库配置</h4><p><img src=\"http://assets.msyy233.com/20180719/135344d3d.png!blog\" alt=\"代理仓库配置\"><br>同样、已经说过的配置就不重复了、<br>Remote Storage Location：远程下载地址、代理仓库、总要有代理仓库地址<br>其他设置也是差不多、看看英文大概就知道什么意思、就不一一列举了  </p>\n","categories":["maven"],"tags":["maven","nexus"]},{"title":"常见开源协议简介","url":"/posts/7105.html","content":"<p>当Adobe、Microsoft、Sun等一系列巨头开始表现出对开源的青睐时、开源的时代早已到来、现今存在的开源协议很多、而经过Open Source Initiative组织通过批准的开源协议目前有<a href=\"http://www.opensource.org/licenses/alphabetical\">83种</a>、我们在常见的开源协议如BSD、GPL、LGPL、MIT等都是OSI批准的协议、如果要开源自己的代码、最好也是选择这些被批准的开源协议、这里我们来看四种最常用的开源协议及它们的适用范围、供那些准备开源或者使用开源产品的开发人员/厂家参考  </p>\n<h2 id=\"BSD开源协议-original-BSD-license-FreeBSD-license-Original-BSD-license\"><a href=\"#BSD开源协议-original-BSD-license-FreeBSD-license-Original-BSD-license\" class=\"headerlink\" title=\"BSD开源协议(original BSD license/FreeBSD license/Original BSD license)\"></a>BSD开源协议(original BSD license/FreeBSD license/Original BSD license)</h2><p>BSD开源协议是一个给于使用者很大自由的协议、基本上使用者可以为所欲为、可以自由的使用、修改源代码、也可以将修改后的代码作为开源或者专有软件再发布、但为所欲为的前提当你发布使用了BSD协议的代码或则以BSD协议代码为基础做二次开发自己的产品时、需要满足三个条件：</p>\n<ol>\n<li><p>如果再发布的产品中包含源代码、则在源代码中必须带有原来代码中的BSD协议、如果再发布的只是二进制类库/软件、则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议、</p>\n</li>\n<li><p>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广、</p>\n</li>\n<li><p>BSD代码鼓励代码共享、但需要尊重代码作者的著作权、BSD由于允许使用者修改和重新发布代码、也允许使用或在BSD代码上开发商业软件发布和销售、因此是对商业集成很友好的协议、而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码、在必要的时候可以修改或者二次开发、</p>\n</li>\n</ol>\n<span id=\"more\"></span>\n<h2 id=\"Apache-Licence-2-0-Apache-License-Version-2-0-Apache-License-Version-1-1-Apache-License-Version-1-0\"><a href=\"#Apache-Licence-2-0-Apache-License-Version-2-0-Apache-License-Version-1-1-Apache-License-Version-1-0\" class=\"headerlink\" title=\"Apache Licence 2.0(Apache License, Version 2.0/Apache License, Version 1.1/Apache License, Version 1.0)\"></a>Apache Licence 2.0(Apache License, Version 2.0/Apache License, Version 1.1/Apache License, Version 1.0)</h2><p>Apache Licence是著名的非盈利开源组织Apache采用的协议、该协议和BSD类似、同样鼓励代码共享和尊重原作者的著作权、同样允许代码修改、再发布(作为开源或商业软件)、需要满足的条件也和BSD类似:</p>\n<ol>\n<li><p>需要给代码的用户一份Apache Licence、如果你修改了代码、需要在被修改的文件中说明、在延伸的代码中(修改和有源代码衍生的代码中)需要带有原来代码中的协议、商标、专利声明和其他原来作者规定需要包含的说明、</p>\n</li>\n<li><p>如果再发布的产品中包含一个Notice文件、则在Notice文件中需要带有Apache Licence、你可以在Notice中增加自己的许可、但不可以表现为对Apache Licence构成更改、</p>\n</li>\n<li><p>Apache Licence也是对商业应用友好的许可、使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售、</p>\n</li>\n</ol>\n<h2 id=\"GPL-GNU-General-Public-License\"><a href=\"#GPL-GNU-General-Public-License\" class=\"headerlink\" title=\"GPL(GNU General Public License)\"></a>GPL(GNU General Public License)</h2><p>我们很熟悉的Linux就是采用了GPL、GPL协议和BSD、Apache Licence等鼓励代码重用的许可很不一样、GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用、但不允许修改后和衍生的代码做为闭源的商业软件发布和销售、这也就是为什么我们能用免费的各种linux、包括商业公司的linux和linux上各种各样的由个人、组织、以及商业软件公司开发的免费软件了、<br>GPL协议的主要内容是只要在一个软件中使用(“使用”指类库引用、修改后的代码或者衍生代码)GPL协议的产品、则该软件产品必须也采用GPL协议、既必须也是开源和免费、这就是所谓的”传染性”、GPL协议的产品作为一个单独的产品使用没有任何问题、还可以享受免费的优势、<br>由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议、对于使用GPL协议的开源代码、商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础、其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似、</p>\n<h2 id=\"LGPL-GNU-Lesser-General-Public-License\"><a href=\"#LGPL-GNU-Lesser-General-Public-License\" class=\"headerlink\" title=\"LGPL(GNU Lesser General Public License)\"></a>LGPL(GNU Lesser General Public License)</h2><p>LGPL是GPL的一个为主要为类库使用设计的开源协议、和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同、LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码、这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售、<br>但是如果修改LGPL协议的代码或者衍生、则所有修改的代码、涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议、因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用、但不适合希望以LGPL协议代码为基础、通过修改和衍生的方式做二次开发的商业软件采用、GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品、</p>\n<h2 id=\"MIT-MIT\"><a href=\"#MIT-MIT\" class=\"headerlink\" title=\"MIT(MIT)\"></a>MIT(MIT)</h2><p>MIT是和BSD一样宽范的许可协议、作者只想保留版权、而无任何其他了限制、也就是说、你必须在你的发行版里包含原许可协议的声明、无论你是以二进制发布的还是以源代码发布的、</p>\n","categories":["other"],"tags":["Apache","BSD","GPL","LGPL","MIT","开源协议"]},{"title":"Excel生成SQL INSERT语句","url":"/posts/12817.html","content":"<h1 id=\"一、领导分配的任务\"><a href=\"#一、领导分配的任务\" class=\"headerlink\" title=\"一、领导分配的任务\"></a>一、领导分配的任务</h1><p><strong>刘总：</strong>小明、你把我给的这些菜单信息导入数据库、<br><strong>小明：</strong>好的、刘总</p>\n<p><em>然后小明作为一个小小的码农、丝毫没有反抗的想法、默默的拿着这样一份的Excel开始想办法</em>  </p>\n<p><img src=\"http://assets.msyy233.com/20180625/1642428c8.png!blog\" alt=\"菜单图片\">  </p>\n<span id=\"more\"></span>\n<h1 id=\"二、解决方案的思考\"><a href=\"#二、解决方案的思考\" class=\"headerlink\" title=\"二、解决方案的思考\"></a>二、解决方案的思考</h1><h2 id=\"（一）2B程序员\"><a href=\"#（一）2B程序员\" class=\"headerlink\" title=\"（一）2B程序员\"></a>（一）2B程序员</h2><p>既然是2B了、拿到手肯定不会想解决方案、而是嘀咕、特么的<del>这种苦力活又要交给我干、然后哼哧哼哧的一个个往数据库里面录、加班加了一个通宵</del>心里默默的骂了一句领导傻逼、</p>\n<h2 id=\"（二）普通程序员\"><a href=\"#（二）普通程序员\" class=\"headerlink\" title=\"（二）普通程序员\"></a>（二）普通程序员</h2><p>一般程序员第一反应肯定是用技能解决问题、心里肯定要盘算盘算、这么多不可能一个个手工录入啊、写个Main函数解析一下吧、Java还是Python呢？Python吧、方便点、</p>\n<h2 id=\"（三）机智的小明\"><a href=\"#（三）机智的小明\" class=\"headerlink\" title=\"（三）机智的小明\"></a>（三）机智的小明</h2><p>小明最讨厌一行行录数据、写一次性脚本了、还有很多失足少女等待他的安抚、晚上宾馆房间都开好了、怎么能为了这么无聊的事情浪费时间呢、只想快点完成任务的他想到了利用Excel功能、简直机智的一比~~~</p>\n<blockquote>\n<p><em>肯定有人要问我、为什么最后不是天才程序员、或者是聪明的程序员而是机智的小明呢？</em><br><strong>因为这样的程序员已经是领导了、而小明还在帮领导干活~ (╥╯^╰╥)</strong></p>\n</blockquote>\n<h1 id=\"三、方案执行\"><a href=\"#三、方案执行\" class=\"headerlink\" title=\"三、方案执行\"></a>三、方案执行</h1><h2 id=\"（一）字符串拼接-quot-amp-XY-amp-quot\"><a href=\"#（一）字符串拼接-quot-amp-XY-amp-quot\" class=\"headerlink\" title=\"（一）字符串拼接&quot;&amp;XY&amp;&quot;\"></a>（一）字符串拼接<code>&quot;&amp;XY&amp;&quot;</code></h2><p><img src=\"http://assets.msyy233.com/20180625/1707189d5.gif!blog\" alt=\"字符串拼接\">  </p>\n<blockquote>\n<p><code>=&quot;&quot;</code>：双引号里面是字符串、双引号中通过公式拼接指定单元格值  </p>\n<p>拼接公式解析：<br>X代表X轴：一般是A到Z的字母、再往后是两位字母<br>Y代表Y轴：都是数字、<br><code>&quot;&amp;XY&amp;&quot;</code>：表示指定单元格的值、使用过程中一定要用双引号包裹、  </p>\n<p><strong>不明白的可以多看两遍GIF</strong></p>\n</blockquote>\n<p>GIF中的拼接公式：<code>=&quot;insert into t_menu(menu_code, menu_name) values(&#39;&quot;&amp;A2&amp;&quot;&#39;, &#39;&quot;&amp;B2&amp;&quot;&#39;);&quot;</code><br>GIF中的第一行值：<code>insert into t_menu(menu_code, menu_name) values(&#39;1000001&#39;, &#39;用户信息&#39;);</code></p>\n<p><strong>值得一提的是如果你需要的是双引号包裹、那么依然需要双引号转义、看下示例：</strong><br><strong>GIF中的拼接公式：<code>=&quot;insert into t_menu(menu_code, menu_name) values(&quot;&quot;&quot;&amp;A2&amp;&quot;&quot;&quot;, &quot;&quot;&quot;&amp;B2&amp;&quot;&quot;&quot;);&quot;</code></strong><br><strong>GIF中的第一行值：<code>insert into t_menu(menu_code, menu_name) values(&quot;1000001&quot;, &quot;用户信息&quot;);</code></strong> </p>\n<h2 id=\"（二）CONCATENATE函数\"><a href=\"#（二）CONCATENATE函数\" class=\"headerlink\" title=\"（二）CONCATENATE函数\"></a>（二）CONCATENATE函数</h2><p><img src=\"http://assets.msyy233.com/20180625/1756307e6.gif!blog\" alt=\"CONCATENATE函数\">  </p>\n<p>GIF中的拼接公式：<code>=CONCATENATE(&quot;insert into t_menu(menu_code, menu_name) value(&#39;&quot;,A2,&quot;&#39;, &#39;&quot;,B2,&quot;&#39;);&quot;)</code><br>GIF中的第一行值：<code>insert into t_menu(menu_code, menu_name) value(&#39;1000001&#39;, &#39;用户信息&#39;);</code></p>\n<p><strong>单个单元格的语法和字符串拼接的一模一样、双引号也同样参照字符串拼接<code>&quot;&amp;XY&amp;&quot;</code>、唯一的区别是、单元格的值不再需要<code>&quot;&amp;XY&amp;&quot;</code>来表示、而是使用拼接的方式实现、</strong> </p>\n<p><strong>同样的不明白多看两遍GIF</strong></p>\n<h1 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h1><p>没有总结了、个人比较喜欢字符串拼接的方式、<strong>值得一提的是这个功能不光可以用来拼SQL、有的时候也可以拼拼代码、看你咋用啦~</strong></p>\n","categories":["trick"],"tags":["excel","sql"]},{"title":"Spring的BeanFactory和FactoryBean","url":"/posts/17047.html","content":"<p>﻿<strong>Spring有两个自带接口、BeanFactory和FactoryBean、这两个接口虽然名字差不多、但是实际上确实完全不一样的两种东西</strong></p>\n<hr>\n<h2 id=\"一、BeanFactory\"><a href=\"#一、BeanFactory\" class=\"headerlink\" title=\"一、BeanFactory\"></a>一、BeanFactory</h2><p>BeanFactory定义了IOC容器的最基本形式、并提供了IOC容器应遵守的的最基本的接口、  也就是Spring IOC所遵守的最底层和最基本的编程规范、  在Spring代码中、BeanFactory只是个接口、并不是 IOC 容器的具体实现</p>\n<p>但是Spring容器给出了很多种实现、如DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext等、都是附加了某种功能的实现、具体我们可以在Eclipse中打开类结构</p>\n<span id=\"more\"></span>\n\n<p><img src=\"http://assets.msyy233.com/20180623/12423018b.png!blog\" alt=\"BeanFactory类结构图\"></p>\n<p><img src=\"http://assets.msyy233.com/20180623/124259128.png!blog\" alt=\"BeanFactory类体系图\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.beans.factory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.BeansException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BeanFactory</span> </span>&#123;</span><br><span class=\"line\">    String FACTORY_BEAN_PREFIX = <span class=\"string\">&quot;&amp;&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">getBean</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">T <span class=\"title\">getBean</span><span class=\"params\">(String name, Class&lt;T&gt; requiredType)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">T <span class=\"title\">getBean</span><span class=\"params\">(Class&lt;T&gt; requiredType)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">    <span class=\"function\">Object <span class=\"title\">getBean</span><span class=\"params\">(String name, Object... args)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">T <span class=\"title\">getBean</span><span class=\"params\">(Class&lt;T&gt; requiredType, Object... args)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">containsBean</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isSingleton</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isPrototype</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTypeMatch</span><span class=\"params\">(String name, Class&lt;?&gt; targetType)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\">    Class&lt;?&gt; getType(String name) <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException;</span><br><span class=\"line\">    String[] getAliases(String name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p><strong>在该接口中定义了一下6种方法</strong></p>\n<ul>\n<li>boolean containsBean(String)：如果BeanFactory包含给定名称的bean定义(或bean实例)、则返回true、</li>\n<li>Object getBean(String)：返回以给定名字注册的bean实例、根据bean的配置情况、如果为singleton模式将返回一个共享的实例、否则将返回一个新建的实例、如果没有找到指定的bean、该方法可能会抛出BeansException异常(实际上将抛出NoSuchBeanDefinitionException异常)、在对bean进行实例化和预处理时也可能抛出异常</li>\n<li>Object getBean(String, Class)：返回以给定名称注册的bean实例、并转换为给定class类型的实例、如果转换失败、相应的异常(BeanNotOfRequiredTypeException)将被抛出、上面的getBean(String)方法也适用该规则</li>\n<li>Class getType(String name)：返回给定名称的bean的Class、如果没有找到指定的bean实例、则抛出NoSuchBeanDefinitionException异常</li>\n<li>boolean isSingleton(String)：判断给定名称的bean定义(或bean实例)是否为singleton模式(singleton将在bean的作用域中讨论)、如果bean没找到、则抛出NoSuchBeanDefinitionException异常</li>\n<li>String[] getAliases(String)：返回给定bean名称的所有别名</li>\n</ul>\n<p><strong>我们初学Spring的时候ClassPathXmlApplicationContext创建获取Bean的对象、实际这就是个BeanFactory实现、看个例子应该能够更好理解</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BeanFactory实现之一XmlBeanFactory</span></span><br><span class=\"line\">Resource resource = <span class=\"keyword\">new</span> FileSystemResource(<span class=\"string\">&quot;applicationContext.xml&quot;</span>);</span><br><span class=\"line\">BeanFactory factory1 = <span class=\"keyword\">new</span> XmlBeanFactory(resource);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AppliactionContext也是BeanFactoryshixian实现、当然包括子类ClassPathXmlApplicationContext</span></span><br><span class=\"line\">ApplicationContext context = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> String[] &#123;<span class=\"string\">&quot;applicationContext.xml&quot;</span>, <span class=\"string\">&quot;applicationContext-part.xml&quot;</span>&#125;</span><br><span class=\"line\">);</span><br><span class=\"line\">BeanFactory factory2 = (BeanFactory) context;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 无论哪种实现都能获取Spring管理的Bean</span></span><br><span class=\"line\">Object o1 = factory1.getBean(<span class=\"string\">&quot;beanName&quot;</span>);</span><br><span class=\"line\">Object o2 = factory2.getBean(<span class=\"string\">&quot;beanName&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>BeanFactory总结：</strong></p>\n<ul>\n<li>BeanFactory它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖</li>\n<li>BeanFactory是访问Spring beans的一个容器、所有的Spring Beans的定义都会在这里被统一的处理</li>\n</ul>\n<p>换句话说、BeanFactory Interface是一个应用组件（Spring Bean）的集中注册器和配置器、从一般意义上来讲、BeanFactory是用来加载和管理Spring Bean Definition的</p>\n<hr>\n<h2 id=\"二、FactoryBean\"><a href=\"#二、FactoryBean\" class=\"headerlink\" title=\"二、FactoryBean\"></a>二、FactoryBean</h2><p>一般情况下、Spring通过反射机制利用<code>&lt;bean&gt;</code> 的class属性指定实现类实例化Bean、在某些情况下、实例化Bean过程比较复杂、如果按照传统的方式、则需要在<code>&lt;bean&gt;</code>中提供大量的配置信息、配置方式的灵活性是受限的、这时采用编码的方式可能会得到一个简单的方案</p>\n<p>Spring为此提供了一个<code>org.springframework.bean.factory.FactoryBean</code>的工厂类接口、用户可以通过实现该接口定制实例化Bean的逻辑、FactoryBean接口对于Spring框架来说占用重要的地位、Spring自身就提供了70多个FactoryBean的实现、它们隐藏了实例化一些复杂Bean的细节、给上层应用带来了便利、从Spring 3.0开始、FactoryBean开始支持泛型、即接口声明改为<code>FactoryBean&lt;T&gt;</code>的形式、同样使用Eclipse打开类结构</p>\n<p><img src=\"http://assets.msyy233.com/20180623/1243281a2.png!blog\" alt=\"FactoryBean类结构图\"></p>\n<p><img src=\"http://assets.msyy233.com/20180623/124505511.png!blog\" alt=\"FactoryBean类体系图\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.springframework.beans.factory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">FactoryBean</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">getObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">    Class&lt;?&gt; getObjectType();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isSingleton</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在该接口中还定义了以下3个方法：</p>\n<ul>\n<li>T getObject()：返回由FactoryBean创建的Bean实例、如果isSingleton()返回 true、则该实例会放到Spring容器中单实例缓存池中</li>\n<li>Class getObjectType()：返回FactoryBean 创建的 Bean 类型、当配置文件中<code>&lt;bean&gt;</code>的class属性配置的实现类是FactoryBean时、通过getBean()方法返回的不是FactoryBean本身、而是FactoryBean的getObject()方法所返回的对象、相当于FactoryBean#getObject()代理了getBean()方法</li>\n<li> boolean isSingleton()：返回由FactoryBean创建的Bean实例的作用域是singleton还是prototype</li>\n</ul>\n<p><strong>FactoryBean总结：</strong></p>\n<ul>\n<li>通常情况下、Bean无须自己实现工厂模式、Spring容器担任工厂角色</li>\n<li>少数情况下、容器中的Bean本身就是工厂、其作用是产生其它bean实例、作用是产生其他bean实例</li>\n</ul>\n<p>这种Bean没有什么特别的要求、仅需要提供一个工厂方法、该方法用来返回其他bean实例、由工厂Bean产生的其他Bean实例、不再由Spring容器产生、因此与普通Bean的配置不同、不再需要提供class元素</p>\n<p><strong>有关FactoryBean的具体使用实例请参见：</strong><a href=\"#\">利用Spring FactoryBean封装HttpClient(我还没写)</a></p>\n<hr>\n<h2 id=\"三、区别\"><a href=\"#三、区别\" class=\"headerlink\" title=\"三、区别\"></a>三、区别</h2><p>BeanFactory是个Factory、也就是IOC容器或对象工厂、FactoryBean是个Bean、在Spring中、所有的Bean都是由BeanFactory来进行管理的、但对FactoryBean而言、这个Bean不是简单的Bean、而是一个能生产或者修饰对象生成的工厂Bean、它的实现与设计模式中的工厂模式和修饰器模式结合（更加偏向工厂模式）</p>\n","categories":["spring"],"tags":["Spring","BeanFactory","FactoryBean"]},{"title":"常见APM技术选型","url":"/posts/25037.html","content":"<h1 id=\"一、技术调研\"><a href=\"#一、技术调研\" class=\"headerlink\" title=\"一、技术调研\"></a>一、技术调研</h1><blockquote>\n<p>Zipkin是Twitter开源的调用链分析工具、目前基于SpringCloud Sleuth得到了广泛的使用、特点是轻量、使用部署简单</p>\n</blockquote>\n<blockquote>\n<p>Pinpoint是韩国人开源的基于字节码注入的调用链分析、以及应用监控分析工具、特点是支持多种插件、UI功能强大、接入端无代码侵入</p>\n</blockquote>\n<blockquote>\n<p>SkyWalking是本土开源的基于字节码注入的调用链分析、以及应用监控分析工具、目前已Apache孵化器毕业、特点是支持多种插件、UI功能强大、接入端无代码侵入、提供应用Agent交互包、</p>\n</blockquote>\n<blockquote>\n<p>CAT是大众点评开源的基于编码和配置的调用链分析、应用监控分析、日志采集、监控报警等一系列的监控平台工具</p>\n</blockquote>\n<blockquote>\n<p>Pradar是数列公司的一个产品、并非开源项目、Pradar和Pinpoint一样也是基于字节码注入的调用链分析、Agent部分的代码也十分相似、</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"（一）技术实现\"><a href=\"#（一）技术实现\" class=\"headerlink\" title=\"（一）技术实现\"></a>（一）技术实现</h2><table>\n<thead>\n<tr>\n<th>类别</th>\n<th>Zipkin</th>\n<th>Pinpoint</th>\n<th>SkyWalking</th>\n<th>CAT</th>\n<th>Pradar</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>实现方式</td>\n<td>拦截请求</td>\n<td>字节码增强</td>\n<td>字节码增强</td>\n<td>代码埋点</td>\n<td>字节码增强</td>\n</tr>\n<tr>\n<td>接入方式</td>\n<td>基于linkerd或者sleuth方式配置</td>\n<td>javaagent</td>\n<td>javaagent</td>\n<td>代码入侵</td>\n<td>javaagent</td>\n</tr>\n<tr>\n<td>OpenTracing</td>\n<td>√</td>\n<td>×</td>\n<td>√</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td>存储</td>\n<td>ES、Mysql、Cassandra、Memory</td>\n<td>Hbase</td>\n<td>ES、JDBC</td>\n<td>MySQL、HDFS</td>\n<td>Hbase、HDFS</td>\n</tr>\n<tr>\n<td>收集协议</td>\n<td>HTTP、MQ</td>\n<td>Thrift、gRPC</td>\n<td>HTTP、gRPC</td>\n<td>HTTP/TCP</td>\n<td>HTTP(代理)</td>\n</tr>\n</tbody></table>\n<h2 id=\"（二）数据分析\"><a href=\"#（二）数据分析\" class=\"headerlink\" title=\"（二）数据分析\"></a>（二）数据分析</h2><table>\n<thead>\n<tr>\n<th>类别</th>\n<th>Zipkin</th>\n<th>Pinpoint</th>\n<th>SkyWalking</th>\n<th>CAT</th>\n<th>Pradar</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>颗粒度</td>\n<td>接口级</td>\n<td>方法级</td>\n<td>方法级(代码级)</td>\n<td>代码级</td>\n<td>方法级</td>\n</tr>\n<tr>\n<td>全局调用统计</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>TraceId查询</td>\n<td>√</td>\n<td>×</td>\n<td>√</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr>\n<td>报警</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr>\n<td>JVM监控</td>\n<td>×</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n<td>×</td>\n</tr>\n<tr>\n<td>UI</td>\n<td>**</td>\n<td>****</td>\n<td>*****</td>\n<td>****</td>\n<td>****</td>\n</tr>\n</tbody></table>\n<h2 id=\"（三）整体架构\"><a href=\"#（三）整体架构\" class=\"headerlink\" title=\"（三）整体架构\"></a>（三）整体架构</h2><h3 id=\"1、Zipkin\"><a href=\"#1、Zipkin\" class=\"headerlink\" title=\"1、Zipkin\"></a>1、Zipkin</h3><p>zipkin分为zipkin服务端和客户端、每一个被监控的服务都是客户端<br><img src=\"http://assets.msyy233.com/20190804/1400456ac.png!blog\" alt=\"Zipkin\"></p>\n<ul>\n<li>追踪器：位于客户端、并记录有关发生的操作的时间和元数据、对用户透明</li>\n<li>Reporter： 将数据发送到Zipkin的检测应用程序</li>\n<li>Transport ：传输数据：HTTP、 Kafka and Scribe</li>\n<li>Collector：位于服务端中、收集传输来的数据</li>\n<li>Storage ：存储数据、默认存储在内存中</li>\n<li>search ：查询Api、JSON应用编程接口、被UI调用</li>\n<li>UI ：Web UI提供了一种基于服务、时间Annotation查看跟踪的方法、没有内置身份验证</li>\n</ul>\n<h3 id=\"2、Pinpoint\"><a href=\"#2、Pinpoint\" class=\"headerlink\" title=\"2、Pinpoint\"></a>2、Pinpoint</h3><p>Pinpoint 完整组件分为五部分: 探针、收集器、流计算、存储和用户界面<br><img src=\"http://assets.msyy233.com/20190804/143636555.png!blog\" alt=\"Pinpoint\"><br><img src=\"http://assets.msyy233.com/20190804/143816931.png!blog\" alt=\"Pinpoint\"></p>\n<ul>\n<li>Pinpoint-Collector：收集各种性能数据</li>\n<li>Pinpoint-Agent：探针与应用关联、部署到同一台服务器上</li>\n<li>Pinpoint-Web：将收集到的数据层现在web展示</li>\n<li>Pinpoint-Flink: 将收集到的数据进行聚合等运算得出指标</li>\n<li>HBase Storage：收集到数据存到HBase中</li>\n</ul>\n<h3 id=\"3、SkyWalking\"><a href=\"#3、SkyWalking\" class=\"headerlink\" title=\"3、SkyWalking\"></a>3、SkyWalking</h3><p>SkyWalking 逻辑上分为四部分: 探针(SkyWalking-agent)、平台后端(oap-server)、存储(es)和用户界面(apm-webapp)<br><img src=\"http://assets.msyy233.com/20190804/11341743c.png!blog\" alt=\"SkyWalking\"></p>\n<ul>\n<li>探针基于不同的来源可能是不一样的（原生代理, SDK 以及 Zipkin, Jaeger 和 OpenCensus ）、但作用都是收集数据、将数据格式化为 SkyWalking 适用的格式</li>\n<li>平台后端是一个支持集群模式运行的后台、用于数据聚合、数据分析以及驱动数据流从探针到用户界面的流程、平台后端还提供了各种可插拔的能力、如不同来源数据(如来自 Zipkin)格式化、不同存储系统以及集群管理、你甚至还可以使用观测分析语言来进行自定义聚合分析</li>\n<li>存储是开放式的、你可以选择一个既有的存储系统、如 ElasticSearch, H2 或 MySQL 集群(Sharding-Sphere 管理)、也可以选择自己实现一个存储系统、</li>\n<li>用户界面对于 SkyWalking 的最终用户来说非常炫酷且强大、同样它也是可定制以匹配你已存在的后端的</li>\n</ul>\n<h3 id=\"4、CAT\"><a href=\"#4、CAT\" class=\"headerlink\" title=\"4、CAT\"></a>4、CAT</h3><p> 整个CAT主要分为三个模块、cat-client、cat-consumer、cat-home</p>\n<ul>\n<li>cat-client 提供给业务以及中间层埋点的底层sdk</li>\n<li>cat-consumer 用于实时分析从客户端的提供的数据</li>\n<li>cat-home 作为用户提供给用户的展示的控制端</li>\n</ul>\n<p> <img src=\"http://assets.msyy233.com/20190804/112442a30.png!blog\" alt=\"CAT\"><br> 上图是CAT目前多机房的整体结构图：</p>\n<ul>\n<li>路由中心是根据应用所在机房信息来决定客户端上报的CAT服务端地址</li>\n<li>每个机房内部都有的独立的原始信息存储集群HDFS</li>\n<li>cat-home可以部署在一个机房也可以部署在多个机房、在做报表展示的时候、cat-home会从cat-consumer中进行跨机房的调用、将所有的数据合并展示给用户</li>\n<li>实际过程中、cat-consumer、cat-home以及路由中心都是部署在一起、每个服务端节点都可以充当任何一个角色</li>\n</ul>\n<h3 id=\"5、Pradar\"><a href=\"#5、Pradar\" class=\"headerlink\" title=\"5、Pradar\"></a>5、Pradar</h3><p>Pradar 整体分为四部分: 探针、log-agent服务、流计算、存储和用户界面<br><img src=\"http://assets.msyy233.com/20190804/144914faa.png!blog\" alt=\"Pradar\"></p>\n<ul>\n<li>Pradar-Agent：收集各种性能数据</li>\n<li>Log-Agent：探针与应用关联、部署到同一台服务器上</li>\n<li>Pradar-Strom：将收集到的数据层现在web展示</li>\n<li>Pinpoint-Flink: 将收集到的数据进行聚合等运算得出指标</li>\n<li>HBase-Storage：收集到数据存到HBase中</li>\n</ul>\n<h2 id=\"（三）社区活跃\"><a href=\"#（三）社区活跃\" class=\"headerlink\" title=\"（三）社区活跃\"></a>（三）社区活跃</h2><h3 id=\"1、当前对比\"><a href=\"#1、当前对比\" class=\"headerlink\" title=\"1、当前对比\"></a>1、当前对比</h3><table>\n<thead>\n<tr>\n<th>类别</th>\n<th>Zipkin</th>\n<th>Pinpoint</th>\n<th>SkyWalking</th>\n<th>CAT</th>\n<th>Pradar</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Star当前数量</td>\n<td>11416</td>\n<td>9099</td>\n<td>9487</td>\n<td>10645</td>\n<td>-</td>\n</tr>\n<tr>\n<td>Issues数量</td>\n<td>235</td>\n<td>98</td>\n<td>51</td>\n<td>22</td>\n<td>-</td>\n</tr>\n<tr>\n<td>代码最后变更</td>\n<td>2天前</td>\n<td>2天前</td>\n<td>21小时前</td>\n<td>13天前</td>\n<td>-</td>\n</tr>\n</tbody></table>\n<h3 id=\"2、增长对比\"><a href=\"#2、增长对比\" class=\"headerlink\" title=\"2、增长对比\"></a>2、增长对比</h3><h4 id=\"1）历史Star\"><a href=\"#1）历史Star\" class=\"headerlink\" title=\"1）历史Star\"></a>1）历史Star</h4><p><img src=\"http://assets.msyy233.com/20190804/1556364e5.png!blog\" alt=\"历史Star\"></p>\n<h4 id=\"2）月增长率\"><a href=\"#2）月增长率\" class=\"headerlink\" title=\"2）月增长率\"></a>2）月增长率</h4><p><img src=\"http://assets.msyy233.com/20190804/161740709.png!blog\" alt=\"Zipkin\"><br><img src=\"http://assets.msyy233.com/20190804/16532153d.png!blog\" alt=\"Zipkin\"></p>\n<hr>\n<p><img src=\"http://assets.msyy233.com/20190804/161834fac.png!blog\" alt=\"Pinpoint\"><br><img src=\"http://assets.msyy233.com/20190804/16530349d.png!blog\" alt=\"Pinpoint\"></p>\n<hr>\n<p><img src=\"http://assets.msyy233.com/20190804/162054577.png!blog\" alt=\"SkyWalking\"><br><img src=\"http://assets.msyy233.com/20190804/16534739b.png!blog\" alt=\"SkyWalking\"></p>\n<hr>\n<p><img src=\"http://assets.msyy233.com/20190804/161910cd5.png!blog\" alt=\"CAT\"><br><img src=\"http://assets.msyy233.com/20190804/165242674.png!blog\" alt=\"CAT\"></p>\n<hr>\n<p><strong><span style=\"color:red\">数据统计日期：2019年8月4日</span></strong></p>\n<h1 id=\"二、巅峰对决\"><a href=\"#二、巅峰对决\" class=\"headerlink\" title=\"二、巅峰对决\"></a>二、巅峰对决</h1><p>公司目前已经有过百系统、并且技术栈相对混乱、经过对以上几种类型APM的剖析、只有使用javaagent类型的接入方式、才能减少冲击、降低成本、考虑pradar有些陈旧、并且很多功能也是存在不少的问题、例如对容器不友好等等情况、本章节将对Pinpoit与SkyWalking进行一次深度对比、</p>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>Pinpoint</th>\n<th>SkyWalking</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>项目发起人</td>\n<td>Woonduk Kang（韩国）</td>\n<td>吴晟（中国）</td>\n</tr>\n<tr>\n<td>Github Star</td>\n<td>9099</td>\n<td>9487</td>\n</tr>\n<tr>\n<td>社区</td>\n<td>非Apache/一般社区</td>\n<td>Apache项目 + QQ官方群交流</td>\n</tr>\n<tr>\n<td>文档</td>\n<td>详细</td>\n<td>详细</td>\n</tr>\n<tr>\n<td>用户</td>\n<td>非常多</td>\n<td>非常多</td>\n</tr>\n<tr>\n<td>OpenTracing兼容</td>\n<td>否</td>\n<td>是</td>\n</tr>\n<tr>\n<td>支持语言</td>\n<td>Java、PHP</td>\n<td>Java、PHP、C#、Node.js、Go</td>\n</tr>\n<tr>\n<td>协议</td>\n<td>Thrift、gRPC</td>\n<td>gRPC</td>\n</tr>\n<tr>\n<td>存储</td>\n<td>Hbase + MySQL</td>\n<td>ES、TiDB、JDBC</td>\n</tr>\n<tr>\n<td>UI丰富度</td>\n<td>一般</td>\n<td>很高</td>\n</tr>\n<tr>\n<td>实现方式</td>\n<td>字节码注入</td>\n<td>字节码注入</td>\n</tr>\n<tr>\n<td>代码入侵性</td>\n<td>无</td>\n<td>无（代码入侵可拥有更多功能）</td>\n</tr>\n<tr>\n<td>扩展性</td>\n<td>低</td>\n<td>高</td>\n</tr>\n<tr>\n<td>TraceId查询</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>告警</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>JVM监控</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>跟踪粒度</td>\n<td>细</td>\n<td>一般</td>\n</tr>\n<tr>\n<td>过滤追踪</td>\n<td>filter配置</td>\n<td>Optional Plguin支持</td>\n</tr>\n<tr>\n<td>性能损耗</td>\n<td>高</td>\n<td>低</td>\n</tr>\n<tr>\n<td>组件</td>\n<td>Agent + Collector + Flink + Web + 存储</td>\n<td>Agent + OAP + Web + 存储 + ZK</td>\n</tr>\n<tr>\n<td>发布包</td>\n<td>War</td>\n<td>Jar</td>\n</tr>\n</tbody></table>\n<p>二者的展示环境：**<a href=\"http://125.209.240.10:10123/\">Pinpoint Live Demo</a>** &nbsp;&nbsp;&nbsp; <strong><a href=\"http://122.112.182.72:8080/\">SkyWalking Live Demo</a></strong></p>\n<h2 id=\"（一）多语言\"><a href=\"#（一）多语言\" class=\"headerlink\" title=\"（一）多语言\"></a>（一）多语言</h2><p>Pinpoint只支持Java和PHP、而SkyWalking支持5种语言：Java, C#, PHP, Node.js, Go、如果公司的服务涉及到多个开发语言、那么SkyWalking会是你更好的选择、并且如果要实现自己的探针、SkyWalking的二次开发成本也比Pinpoint更低、所以，支持语言方面，SkyWalking更胜一筹。</p>\n<h2 id=\"（二）协议\"><a href=\"#（二）协议\" class=\"headerlink\" title=\"（二）协议\"></a>（二）协议</h2><p>SkyWalking支持gRPC和HTTP、不过建议使用gRPC、SkyWalking6.x版本已经不提供HTTP方式（但是还会保留接收5.x的数据）、以后会考虑删除、而Pinpoint使用的是thrift协议、协议本身没有谁好谁坏、</p>\n<h2 id=\"（三）存储\"><a href=\"#（三）存储\" class=\"headerlink\" title=\"（三）存储\"></a>（三）<span style=\"color:red\">存储</span></h2><p>存储是SkyWalking和Pinpoint最大的差异所在、因为底层存储决定了上层功能、Pinpoint只支持HBase、且扩展代价较大、</p>\n<p>如果选择Pinpoint、还要有能力hold住一套HBase集群（DaoCloud从Pinpoint切换到SkyWalking就是因为HBase的维护代价有点大）、在这方面、SkyWalking支持的存储就多很多、这样的话、技术选型时可以根据团队技术特点选择合适的存储、而且还可以自行扩展（不过生产环境上应该大部分是以es存储为主）</p>\n<p>Pinpoint只支持HBase的另一个缺陷就是、HBase本身查询能力有限（HBase只能支持三种方式查询：RowKey精确查找、SCAN范围查找、全表扫描）限制了Pinpoint的查询能力、所以其支持的查询一定是在时间的基础上（Pinpoint通过鼠标圈定一个时间范围后查看这个范围内的Trace信息）、而SkyWalking可以多个维度任意组合查询、例如：时间范围、服务名、Trace状态、请求路径、TraceId等</p>\n<p>Pinpoint和SkyWalking都支持TTL、即历史数据保留策略、SkyWalking是在OAP模块的application.yml中配置从而指定保留时间、而Pinpoint是通过HBase的ttl功能实现、通过Pinpoint提供的HBase脚本</p>\n<p>ES并不是完全碾压HBase、ES和HBase没有绝对的好和坏、ES强在检索能力、存储能力偏弱、HBase强在存储能力、检索能力偏弱、如果搜集的日志量非常庞大、那么es存储就比较吃力、同样的、如果对检索能力有一定的要求、那么HBase肯定满足不了你、所以又到了根据你的业务和需求决定的时刻了、trade-off真是无所不在</p>\n<h2 id=\"（四）UI界面\"><a href=\"#（四）UI界面\" class=\"headerlink\" title=\"（四）UI界面\"></a>（四）UI界面</h2><p>Pinpoint的UI早期确实要比SkyWalking强上不少、尤其是服务的拓扑图展示、不过DaoCloud根据Pinpoint的风格为SkyWalking定制了一款UI(Rocketbot)、随着社区的发展已经贡献给SkyWalking成为官方UI了、所以用5.x版本的SkyWalking比较、Pinpoint UI更胜一筹、6.x版本SkyWalking UI更胜一筹</p>\n<h2 id=\"（五）扩展性\"><a href=\"#（五）扩展性\" class=\"headerlink\" title=\"（五）扩展性\"></a>（五）<span style=\"color:red\">扩展性</span></h2><p>Pinpoint好像设计之初就没有过多考虑扩展性、无论是底层的存储、还是自定义探针实现等、而SkyWalking核心设计目标之一就是Pluggable、</p>\n<p>以存储为例、Pinpoint完全没有考虑扩展性、而SkyWalking从设计理念上就是SPI模式、实现一些接口配置就可以完成存储扩展、至于Pinpoint则完全没有考虑过扩展底层存储、</p>\n<p>再以实现一个自己的探针为例、Pinpoint 在实现之初就考虑到了性能问题、因此会选择 Thrift 的二进制变长编码格式、而且使用 UDP 作为传输链路、同时在传递常量的时候也尽量使用数据参考字典、这些优化也增加了系统的复杂度：包括使用 Thrift 接口的难度、UDP 数据传输的问题、以及数据常量字典的注册问题等等、Pinpoint发展这么年才支持Java和PHP、可见一斑、目前Pinpoint最新代码也在使用gRPC、而SkyWalking的数据接口就标准很多、并且支持OpenTracing协议、除了官方支持Java以外、C#、PHP、Go和Node.js的支持都是由社区开发并维护、</p>\n<p>还有后面会提到的告警、SkyWalking的可扩展性也要远好于Pinpoint、</p>\n<h2 id=\"（六）告警\"><a href=\"#（六）告警\" class=\"headerlink\" title=\"（六）告警\"></a>（六）告警</h2><p>Pinpoint和SkyWalking都支持自定义告警规则、但是Pinpoint如果要配置告警规则、还需要安装MySQL(配置告警时的用户、用户组信息以及告警规则都持久化保存在MySQL中)、这就导致Pinpoint的维护成本又高了一些、既要维护HBase又要维护MySQL、</p>\n<p>Pinpoint支持的告警规则有：SLOW COUNT|RATE, ERROR COUNT|RATE, TOTAL COUNT, SLOW COUNT|RATE TO CALLEE, ERROR COUNT|RATE TO CALLEE, ERROR RATE TO CALLEE, HEAP USAGE RATE, JVM CPU USAGE RATE, DATASOURCE CONNECTION USAGE RATE</p>\n<p>Pinpoint每3分钟周期性检查过去5分钟的数据、如果有符合规则的告警、就会发送sms/email给用户组下的所有用户、需要说明的是、实现发送sms/email的逻辑需要自己实现、Pinpoint只提供了接口com.navercorp.pinpoint.web.alarm.AlarmMessageSender、并且Pinpoint发现告警持续时、会递增发送sms/email的时间间隔 3min -&gt; 6min -&gt; 12min -&gt; 24min、防止sms/email狂刷</p>\n<p>SkyWalking支持的告警规则有：service_resp_time, service_sla, service_cpm, service_p99, service_p95, service_p90, service_p75, service_p50, service_instance_sla, service_instance_resp_time, service_instance_cpm, endpoint_cpm, endpoint_avg, endpoint_sla, endpoint_p99, endpoint_p95, endpoint_p90, endpoint_p75, endpoint_p50。</p>\n<p>SkyWalking通过HttpClient的方式远程调用在配置项webhooks中定义的告警通知服务地址、SkyWalking也支持silence-period配置、假设在TN这个时间点触发了告警、那么TN -&gt; TN + period 这段时间内不会再重复发送该告警</p>\n<p>Pinpoint和SkyWalking都支持常用的告警规则配置、SkyWalking采用webhooks的方式就灵活很多、但是需要自己开发webhooks接口、短信通知、邮件通知、微信通知都是可以支持的、而Pinpoint虽然免去了开发接口的工作量、但是只能sms/email通知、并且还需要引入MySQL存储、增加了整个系统复杂度、所以、告警方面、SkyWalking更胜一筹</p>\n<h2 id=\"（七）JVM监控\"><a href=\"#（七）JVM监控\" class=\"headerlink\" title=\"（七）JVM监控\"></a>（七）JVM监控</h2><p>Pinpoint能够监控的指标主要有：Heap、 Non-Heap、 FGC、 DirectBufferMemory、MappedBufferMemory、但是没有YGC<br>SkyWalking支持监控：Heap、Non-Heap、YGC、FGC</p>\n<p>另外、Pinpoint还支持多个指标同一时间点查看的功能、所以、对JVM的监控方面、Pinpoint更胜一筹</p>\n<h2 id=\"（八）服务监控\"><a href=\"#（八）服务监控\" class=\"headerlink\" title=\"（八）服务监控\"></a>（八）服务监控</h2><p>包括操作系统和部署的服务实例的监控、</p>\n<p>Pinpoint支持的维度有：CPU使用率、Open File Descriptor、数据源、活动线程数、RT、TPS、<br>SkyWalking支持的维度有：CPU使用率、SLA、RT、CPM（Call Per Minutes）。</p>\n<p>所以、这方面两者旗鼓相当、没有明显的差距</p>\n<h2 id=\"（九）跟踪粒度\"><a href=\"#（九）跟踪粒度\" class=\"headerlink\" title=\"（九）跟踪粒度\"></a>（九）跟踪粒度</h2><p>Pinpoint在这方面做的非常好、跟踪粒度非常细、在跟踪粒度方面、Pinpoint完胜、</p>\n<h2 id=\"（十）过滤追踪\"><a href=\"#（十）过滤追踪\" class=\"headerlink\" title=\"（十）过滤追踪\"></a>（十）过滤追踪</h2><p>Pinpoint和SkyWalking都可以实现、而且配置的表达式都是基于ant风格、Pinpoint在Web UI上配置 filter wizard 即可自定义过滤追踪、SkyWalking通过加载apm-trace-ignore-plugin插件就能自定义过滤跟踪、两种配置方式各有优势、所以、这方面两者旗鼓相当、没有明显的差距</p>\n<h2 id=\"（十一）性能损耗\"><a href=\"#（十一）性能损耗\" class=\"headerlink\" title=\"（十一）性能损耗\"></a>（十一）性能损耗</h2><p>由于Pinpoint采集信息太过详细、所以、它对性能的损耗很大、而SkyWalking默认策略比较保守、对性能损耗较小、所以、在性能损耗方面、SkyWalking更胜一筹、有网友做过压力测试，对比如下：<br><img src=\"http://assets.msyy233.com/20190804/1927536d2.png!blog\" alt=\"PerfomanceTest\"></p>\n<h2 id=\"（十二）发布包\"><a href=\"#（十二）发布包\" class=\"headerlink\" title=\"（十二）发布包\"></a>（十二）发布包</h2><p>SkyWalking与时俱进、全系标配jar包、部署只需要执行start.sh脚本即可、而Pinpoint的collector和web还是war包、部署时依赖web容器、所以、在发布包方面、SkyWalking更胜一筹、</p>\n<h2 id=\"（十三）支持组件\"><a href=\"#（十三）支持组件\" class=\"headerlink\" title=\"（十三）支持组件\"></a>（十三）支持组件</h2><p><a href=\"http://naver.github.io/pinpoint/1.8.4/main.html\">Pinpoint支持组件</a> &nbsp;&nbsp; <a href=\"https://github.com/apache/skywalking/blob/master/docs/en/setup/service-agent/java-agent/Supported-list.md\">SkyWalking支持组件</a>、这个毫无疑问也是Pinpoint更胜一筹、</p>\n<h1 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h1><p>经过前面对SkyWalking和Pinpoint全方位对比后我们发现、对于两款非常优秀的APM软件、有一种既生瑜何生亮的感觉、</p>\n<p>Pinpoint的优势在于：追踪数据粒度非常细、功能强大的用户界面、以及使用HBase作为存储带来的海量存储能力、<br>SkyWalking的优势在于：非常活跃的中文社区、支持多种语言的探针、使用es作为底层存储带来的强大的检索能力、并且SkyWalking的扩展性以及定制化要更优于Pinpoint、</p>\n<p>如果有海量的日志存储需求、推荐Pinpoint、如果更看重二次开发的便捷性、推荐SkyWalking、参考上面的对比、结合需求、哪些不能妥协、哪些可以舍弃、从而更好的选择一款最适合自己的APM软件</p>\n<hr>\n<p><strong>参考资料：</strong><br><a href=\"https://www.jianshu.com/p/7c719a75df8c\">Dapper分布式跟踪系统</a><br><a href=\"https://www.jianshu.com/p/0fbbf99a236e?from=singlemessage&isappinstalled=0\">调用链选型之Zipkin，Pinpoint，SkyWalking，CAT</a><br><a href=\"https://www.jianshu.com/p/626cae6c0522\">APM巅峰对决：skywalking P.K. Pinpoint</a><br><a href=\"https://github.com/dianping/cat/wiki/overall\">CAT 整体设计</a><br><a href=\"https://naver.github.io/pinpoint/overview.html\">Pinpoint Overview</a><br><a href=\"https://github.com/apache/skywalking\">Github SkyWalking</a><br><a href=\"https://zipkin.io/pages/architecture.html\">Zipkin Architecture Overview</a></p>\n","categories":["apm"],"tags":["pinpoint","zipkin","SkyWalking","pradar","cat"]},{"title":"关于分布式日志平台的思考","url":"/posts/14778.html","content":"<h1 id=\"日志的基本概念\"><a href=\"#日志的基本概念\" class=\"headerlink\" title=\"日志的基本概念\"></a>日志的基本概念</h1><p>日志就是按照时间顺序追加的、完全有序的记录序列、其实就是一种特殊的文件格式、文件是一个字节数组、而这里日志是一个记录数据、只是相对于文件来说、这里每条记录都是按照时间的相对顺序排列的、可以说日志是最简单的一种存储模型、</p>\n<h1 id=\"常见的日志框架\"><a href=\"#常见的日志框架\" class=\"headerlink\" title=\"常见的日志框架\"></a>常见的日志框架</h1><p>目前主流几款日志框架为log4j、logback、log4j2、jdk-logging等、当然绝大多数情况下大家都使用了sl4j框架作为日志门面、<br>不同日志框架API也相差不大、基本都是依赖Append记录、例如：log4j2和log4j都有自己和官方实现的Kafka Append、logback可能需要自己开发、<br>在Append的背后还有Encoder/Layout、简单的说就是日志输出的格式、不同框架的命名虽然不同、但是概念也是完全相同的、实现自己的Encoder/Layout格式化Event输出到文件、再通过收集工具处理、与直接改造Append输出到对应后端是日志收集的常见做法、</p>\n<p>除了logback原生实现了sl4j门面、其他的框架大都提供了对应的桥接工具包、大体逻辑可以参考下图：</p>\n<span id=\"more\"></span>\n<p><img src=\"http://assets.msyy233.com/20191126/153813590.png!blog\" alt=\"日志桥接模式\"></p>\n<h1 id=\"日志平台技术栈\"><a href=\"#日志平台技术栈\" class=\"headerlink\" title=\"日志平台技术栈\"></a>日志平台技术栈</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>日志主要包括系统日志、应用程序日志和安全日志、系统运维和开发人员可以通过日志了解服务器软硬件信息、检查配置过程中的错误及错误发生的原因、经常分析日志可以了解服务器的负荷、性能安全性、从而及时采取措施纠正错误、<br>通常、日志被分散在储存不同的设备上、如果你管理数十上百台服务器、你还在使用依次登录每台机器的传统方法查阅日志、这样是不是感觉很繁琐和效率低下、当务之急我们使用集中化的日志管理、将所有服务器上的日志收集汇总、<br>集中化管理日志后、日志的统计和检索又成为一件比较麻烦的事情、一般我们使用grep、awk和wc等Linux命令能实现检索和统计、但是对于要求更高的查询、排序和统计等要求和庞大的机器数量依然使用这样的方法难免有点力不从心、<br>大数据时代、随着数据量不断增长、存储与计算集群的规模也逐渐扩大、几百上千台的云计算环境已不鲜见、现在的集群所需要解决的问题不仅仅是高性能、高可靠性、高可扩展性、还需要面对易维护性以及数据平台内部的数据共享性等诸多挑战、优秀的系统运维平台既能实现数据平台各组件的集中式管理、方便系统运维人员日常监测、提升运维效率，又能反馈系统运行状态给系统开发人员、<strong>实现并解决上述功能和痛点的系统就是日志平台</strong>、</p>\n<h2 id=\"阶段\"><a href=\"#阶段\" class=\"headerlink\" title=\"阶段\"></a>阶段</h2><ol>\n<li><p><strong>初阶</strong>：日志没有集中式处理、只做事后追查、黑客入侵后删除日志无法察觉、使用数据库存储日志、无法胜任复杂事务处理、</p>\n</li>\n<li><p><strong>中阶</strong>：将日志收集后集中管理查询、作为代表的解决方案有ELK、能够进行简单的搜索、分析、但是日志间无关联性、并且不具备实时分析告警等功能、</p>\n</li>\n<li><p><strong>高阶</strong>：建立出日志与日志间建立联系、再进行集中收集管理、配合流处理框架实时分析告警、企业定制业务关联、高速便捷查询同时、精准对一些异常进行告警、</p>\n</li>\n</ol>\n<h2 id=\"收集\"><a href=\"#收集\" class=\"headerlink\" title=\"收集\"></a>收集</h2><p>日志收集技术目前庞杂广泛、且没有其中一个技术能够异常出彩、难以筛选、并且每个产品因为定位不同、绝大部分居然并没有太多可比性、调研有以下产品、这里会对每个产品有个简单的介绍、</p>\n<h3 id=\"Filebeat\"><a href=\"#Filebeat\" class=\"headerlink\" title=\"Filebeat\"></a>Filebeat</h3><p>目前搜索结果最多的收集工具、也是Elastic家族一员、热度也是相当高、可能有大批量ELK用户吧、  </p>\n<h4 id=\"基本功能\"><a href=\"#基本功能\" class=\"headerlink\" title=\"基本功能\"></a>基本功能</h4><blockquote>\n<p>支持<strong>输入</strong>端：Log、Stdin、Container、Kafka、UDP、Docker、Redis、TCP、Syslog、s3、NetFlow、Google Pub/Sub<br>支持<strong>输出</strong>端：Elasticsearch、Logstash、Kafka、Redis、File、Console、Elastic Cloud  </p>\n</blockquote>\n<p>内置了常见的<strong>日志模块</strong>、可以几行代码就达到基本框架的收集、</p>\n<blockquote>\n<p>目前支持模块：Apache、Auditd、AWS、azure、CEF、Cisco、Coredns、Elasticsearch、Envoyproxy、Google Cloud、haproxy、IBM MQ、Icinga、IIS、Iptables、Kafka、Kibana、Logstash、MISP、MongoDB、MSSQL、MySQL、nats、NetFlow、Nginx、Osquery、Palo Alto Networks、PostgreSQL、RabbitMQ、Redis、Santa、Suricata、System、Traefik、Zeek (Bro) Module</p>\n</blockquote>\n<p>支持<strong>背压敏感协议</strong>、当与Elastic家族其他组件整合时、例如Logstash与Elasticsearch作为输出端、当它们很忙的时候会减慢读取与传输速度、一旦恢复正常、那么将恢复原来的速度、</p>\n<p>另外还支持<strong>多行日志、JSON解析、动态配置和processors</strong>、关于processors大致就是流式处理、示意：<code>event -&gt; processor1 -&gt; event1 -&gt; processor2 -&gt; event2</code></p>\n<p>Filebeat是Beats家族的一员、最初的目的就是为了解决Logstash太重而设计、非常轻量、性能和稳定性也很高、当然你也可以<strong>基于libbeats定制自己的Beats</strong>、</p>\n<h4 id=\"代码结构\"><a href=\"#代码结构\" class=\"headerlink\" title=\"代码结构\"></a>代码结构</h4><p><img src=\"http://assets.msyy233.com/20191226/103619397.png!blog\" alt=\"filebeat\"><br>从代码的实现角度来看、filebeat大概可以分以下几个模块：</p>\n<ul>\n<li>input：找到配置的日志文件、启动harvester</li>\n<li>harvester：读取文件、发送至处理程序spooler</li>\n<li>spooler：缓存日志数据、直到可以发送至publisher</li>\n<li>publisher：发送日志至后端、同时通知registrar</li>\n<li>registrar：记录日志文件被采集的状态</li>\n</ul>\n<h4 id=\"内部逻辑\"><a href=\"#内部逻辑\" class=\"headerlink\" title=\"内部逻辑\"></a>内部逻辑</h4><p><img src=\"http://assets.msyy233.com/20191226/101013f11.png!blog\" alt=\"filebeat\"><br>当你开启filebeat程序的时候、它抽象出一个crawler的结构体、crawler会根据配置创建，然后遍历并运行每个input、获取匹配的日志文件后、会对每一个日志文件启动harvester进程、每一个harvester进程读取一个日志文件的新内容、并发送这些新的日志数据到spooler集合这些事件、最后filebeat会通过publisher发送集合的数据到你指定的地点并记录到registrar</p>\n<h4 id=\"性能问题\"><a href=\"#性能问题\" class=\"headerlink\" title=\"性能问题\"></a>性能问题</h4><p>值得注意正常启动filebeat、一般确实只会占用30-40MB内存、但是在容器云上偶发性的某些节点上的<strong>filebeat容器内存占用超过配置的pod limit限制、并且不停的触发的OOM、</strong><br>究其原因、一般容器化环境中、特别是裸机上运行的容器个数可能会比较多、导致创建大量的harvester去采集日志、如果没有很好的配置filebeat、会有较大概率导致内存急剧上升、  </p>\n<p>filebeat内存占据较大的部分还是memqueue、所有采集到的日志都会先发送至memqueue聚集、再通过output发送出去、每条日志的数据在filebeat中都被组装为event结构、<strong>filebeat默认配置的memqueue缓存的event个数为4096</strong>、可通过queue.mem.events设置、默认最大的<strong>一条日志的event大小限制为10MB</strong>、可通过max_bytes设置、<strong>4096 * 10MB = 40GB</strong>、极端场景下、filebeat至少占据40GB的内存、特别是配置了<strong>multiline多行模式</strong>的情况下、如果multiline配置有误、单个event误采集为上千条日志的数据、很可能导致memqueue占据了大量内存、致使内存爆炸、</p>\n<p>合理的配置<strong>日志文件的匹配规则、限制单行日志大小、根据实际情况配置memqueue缓存的个数</strong>、才能在实际使用中规避filebeat的内存占用过大的问题、</p>\n<h4 id=\"灵活扩展\"><a href=\"#灵活扩展\" class=\"headerlink\" title=\"灵活扩展\"></a>灵活扩展</h4><p>一般情况下filebeat可满足大部分的日志采集需求、但是仍然避免不了一些特殊的场景需要我们对filebeat进行定制化开发、当然filebeat本身的设计也提供了良好的扩展性、</p>\n<p>Beats系列目前只提供了像elasticsearch、kafka、logstash等几类output客户端、如果我们想要filebeat直接发送至其他后端、需要定制化开发自己的output、同样、如果需要对日志做过滤处理或者增加元信息、也可以自制processor插件  </p>\n<p>无论是增加output还是写个processor、filebeat提供的大体思路基本相同、一般来讲有3种方式：</p>\n<ol>\n<li><p>在现有的源码上开发、output或者processor都提供了类似Run、Stop等的接口、只需要实现该类接口、然后在init方法中注册相应的插件初始化方法即可、但由于golang中init方法是在import包时才被调用、所以需要在初始化filebeat的代码中手动import</p>\n</li>\n<li><p>复制一份filebeat的main.go、import我们自研的插件库、然后重新编译、本质上和方式1区别不大、</p>\n</li>\n<li><p>filebeat还提供了基于golang plugin的插件机制、需要把自研的插件编译成.so共享链接库、然后在filebeat启动参数中通过-plugin指定库所在路径、不过实际上一方面golang plugin还不够成熟稳定、一方面自研的插件依然需要依赖相同版本的libbeat库、而且还需要相同的golang版本编译、坑可能更多、不太推荐、</p>\n</li>\n</ol>\n<h4 id=\"集中配置\"><a href=\"#集中配置\" class=\"headerlink\" title=\"集中配置\"></a>集中配置</h4><p>非常遗憾、目前Beats系列集中配置的管理界面只支持Kibana、并且这个功能还是商业版本、需要购买Elastic Gold、不过官方已经申明在不久的将来、还计划公开一个API、以便更轻松地与外部工具和系统集成、未来可以基于API开发自己的统一管理UI</p>\n<h3 id=\"Fluent-bit\"><a href=\"#Fluent-bit\" class=\"headerlink\" title=\"Fluent-bit\"></a>Fluent-bit</h3><p>这个是Fluentd对标Filebeat的组件、虽然性能很高、但由于<strong>只支持Centos7</strong>、考虑公司还是有些系统跑在Centos6上面、并且项目本身热度也不高、所以并没有深入研究、</p>\n<h3 id=\"Flume\"><a href=\"#Flume\" class=\"headerlink\" title=\"Flume\"></a>Flume</h3><p>这个严格来说只能算数据传输工具、并非日志收集工具、并且当数据爆发时、就要考虑性能、Flume有多种收集方式、但是Flume以文件大小为分割来发送一个event、这造成了日志在采集的过程中、很难被结构化、日志只能按照原来的模样原样保存、Flume在收集log的时候经常会出现<code>Line length exceeds max (2048), truncating line!</code>、这个对于一些并且不需要完整性的event没影响、但是遇到需要解析log的情况就有问题了、有时一个json或者其他格式的log被截断了，解析也会出问题，所以在source的属性配置里可以通过参数deserializer.maxLineLength调高默认的2048、  </p>\n<p>总的来说Flume更倾向于传输而非收集、目前美团是实用此技术收集日志的、但是我认为作为一款单纯的日志收集工具并不合适、并且性能也比较难把控、</p>\n<h3 id=\"Logstash\"><a href=\"#Logstash\" class=\"headerlink\" title=\"Logstash\"></a>Logstash</h3><p>这个工具就不说了、我们公司也在运用、网上评价都是功能很强大、性能妥妥的不行、而且对于一些定制化场景肯定也是不行的、可以用Flink + Drools代替。</p>\n<h3 id=\"Fluentd\"><a href=\"#Fluentd\" class=\"headerlink\" title=\"Fluentd\"></a>Fluentd</h3><p>比较依赖结构化，且性能较差；笔者不是很熟，但是公司有实践经验，目前也是希望替换成Filebeat。</p>\n<h2 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h2><p>管道部分并没有太难以筛选、基本业界都是使用Kafka、下面Kafka的一点介绍、</p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li><p>Broker : Kafka集群包含一个或多个服务器，这种服务器被称为broker。</p>\n</li>\n<li><p>Topic : 每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</p>\n</li>\n<li><p>Partition : Partition是物理上的概念，每个Topic包含一个或多个Partition，多个Partition均匀分布在多个Broker节点上。</p>\n</li>\n<li><p>Producer : 消息生产者，负责发布消息到Kafka broker，一个典型的Kafka集群中包含若干Producer，Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高。</p>\n</li>\n<li><p>Consumer :消息消费者，向Kafka broker读取消息的客户端。同一个消费组，一个Partition只支持一个消费线程来消费消息。</p>\n</li>\n<li><p>Consumer Group : 每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。</p>\n</li>\n</ul>\n<p><img src=\"http://assets.msyy233.com/20200713/223923e00.png!blog\" alt=\"拓扑结构图\"></p>\n<p><img src=\"http://assets.msyy233.com/20200713/224011256.png!blog\" alt=\"Zookeeper存储结构\"></p>\n<h3 id=\"Partiton-Replication原则\"><a href=\"#Partiton-Replication原则\" class=\"headerlink\" title=\"Partiton Replication原则\"></a>Partiton Replication原则</h3><p>Kafka把topic中一个Partition大文件分成多个小文件段，多个Partition均匀分布在多个Broker节点上。通过索引信息可以快速定位message和确定response的最大大小；通过index元数据全部映射到memory，可以避免segment file的IO磁盘操作；通过索引文件稀疏存储，可以大幅降低index文件元数据占用空间大小。</p>\n<p><img src=\"http://assets.msyy233.com/20200713/224231a56.jpg!blog\" alt=\"4个Partition，2 Replication\"></p>\n<p><img src=\"http://assets.msyy233.com/20200713/22462319d.jpg!blog\" alt=\"4个Partition，2 Replication\"></p>\n<h3 id=\"高可用\"><a href=\"#高可用\" class=\"headerlink\" title=\"高可用\"></a>高可用</h3><ul>\n<li>replication机制，多副本默认自动均匀分配在各集群节点上。</li>\n<li>Kafka Broker Leader遴选机制，每个Broker都有均等分配Partition的Leader机会。Kakfa Broker集群受Zookeeper管理。</li>\n</ul>\n<h3 id=\"Partition中segment文件存储结构\"><a href=\"#Partition中segment文件存储结构\" class=\"headerlink\" title=\"Partition中segment文件存储结构\"></a>Partition中segment文件存储结构</h3><ul>\n<li>segment有index和data两部分组成，后缀为.index，.log，.index为索引文件，.log数据文件。index采用稀疏存储方式，并不是每一条数据都对应一条索引数据。</li>\n<li>第一个segment文件从0开始，后续的文件名采用上一个文件的最大offset+1命名。</li>\n<li>data数据采用顺序写入。</li>\n</ul>\n<h3 id=\"Kafka性能瓶颈\"><a href=\"#Kafka性能瓶颈\" class=\"headerlink\" title=\"Kafka性能瓶颈\"></a>Kafka性能瓶颈</h3><ul>\n<li>增加partition能提高Kafka吞吐量，当partition数据达到阈值时。增加partition会引起Kafka吞吐量下降。</li>\n<li>当Topic数量达到一定阈值时，增加Topic，Kafka吞吐量明显下降。由于Kafka的每个Topic、每个分区都会对应一个物理文件。当Topic数量增加时，消息分散的落盘策略会导致磁盘IO竞争激烈成为瓶颈。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Topic数量</th>\n<th>发送端并发数</th>\n<th>发送端RT（ms）</th>\n<th>发送端TPS</th>\n<th>消费端TPS</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>64</td>\n<td>800</td>\n<td>5</td>\n<td>13.6w</td>\n<td>13.6w</td>\n</tr>\n<tr>\n<td>128</td>\n<td>256</td>\n<td>23</td>\n<td>8500</td>\n<td>8500</td>\n</tr>\n<tr>\n<td>256</td>\n<td>256</td>\n<td>133</td>\n<td>2352</td>\n<td>2352</td>\n</tr>\n</tbody></table>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>分析部分考虑使用流处理框架、通过订阅Kafka的日志、进行不同逻辑处理、现阶段新系统选择Flink已经是不争的事实、由于功能定位上都较为相似、Storm和Flink主要是对比性能就可以了、以下为对比资料、</p>\n<h3 id=\"功能对比\"><a href=\"#功能对比\" class=\"headerlink\" title=\"功能对比\"></a>功能对比</h3><table>\n<thead>\n<tr>\n<th>功能</th>\n<th>Storm</th>\n<th>Flink</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>状态管理</td>\n<td>无状态，需用户自行进行状态管理</td>\n<td>有状态</td>\n</tr>\n<tr>\n<td>窗口支持</td>\n<td>对事件窗口支持较弱，缓存整个窗口的所有数据，窗口结束时一起计算</td>\n<td>窗口支持较为完善，自带一些窗口聚合方法，并且会自动管理窗口状态。</td>\n</tr>\n<tr>\n<td>消息传递</td>\n<td>At Most Once<br>At Least Once</td>\n<td>At Most Once<br>At Least Once<br> Exactly Once</td>\n</tr>\n<tr>\n<td>容错方式</td>\n<td><a href=\"http://storm.apache.org/releases/1.1.0/Guaranteeing-message-processing.html\">ACK机制</a> ：对每个消息进行全链路跟踪，失败或超时进行重发。</td>\n<td><a href=\"https://ci.apache.org/projects/flink/flink-docs-master/internals/stream_checkpointing.html#checkpointing\">检查点机制</a> ：通过分布式一致性快照机制，对数据流和算子状态进行保存。在发生错误时，使系统能够进行回滚。</td>\n</tr>\n<tr>\n<td>应用现状</td>\n<td>在美团点评实时计算业务中已有较为成熟的运用，有管理平台、常用 API 和相应的文档，大量实时作业基于 Storm 构建。</td>\n<td>在美团点评实时计算业务中已有一定应用，但是管理平台、API 及文档等仍需进一步完善。</td>\n</tr>\n</tbody></table>\n<h3 id=\"性能对比\"><a href=\"#性能对比\" class=\"headerlink\" title=\"性能对比\"></a>性能对比</h3><p>这里主要通过以下两个指标来衡量各场景性能、  </p>\n<p>吞吐量（Throughput）：<em><strong>单位时间内由计算框架成功地传送数据的数量，本次测试吞吐量的单位为：条/秒。反映了系统的负载能力，在相应的资源条件下，单位时间内系统能处理多少数据。</strong></em> 吞吐量常用于资源规划，同时也用于协助分析系统性能瓶颈，从而进行相应的资源调整以保证系统能达到用户所要求的处理能力。假设商家每小时能做二十份午餐（吞吐量 20 份/小时），一个外卖小哥每小时只能送两份（吞吐量 2 份/小时），这个系统的瓶颈就在小哥配送这个环节，可以给该商家安排十个外卖小哥配送。</p>\n<p>延迟（Latency）：<em><strong>数据从进入系统到流出系统所用的时间，本次测试延迟的单位为：毫秒。反映了系统处理的实时性。金融交易分析等大量实时计算业务对延迟有较高要求，延迟越低，数据实时性越强。</strong></em> 假设商家做一份午餐需要 5 分钟，小哥配送需要 25 分钟，这个流程中用户感受到了 30 分钟的延迟。如果更换配送方案后延迟变成了 60 分钟，等送到了饭菜都凉了，这个新的方案就是无法接受的。</p>\n<p>对比测试的参数配置：</p>\n<ul>\n<li>Storm 和 Flink 默认均为 At Least Once 语义。</li>\n<li>Storm 开启 ACK，ACKer 数量为 1。</li>\n<li>Flink 的 Checkpoint 时间间隔为 30 秒，默认 StateBackend 为 Memory。</li>\n</ul>\n<h4 id=\"集群参数\"><a href=\"#集群参数\" class=\"headerlink\" title=\"集群参数\"></a>集群参数</h4><table>\n<thead>\n<tr>\n<th>参数项</th>\n<th>参数值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CPU</td>\n<td>QEMU Virtual CPU version 1.1.2 2.6GHz</td>\n</tr>\n<tr>\n<td>Core</td>\n<td>8</td>\n</tr>\n<tr>\n<td>Memory</td>\n<td>16GB</td>\n</tr>\n<tr>\n<td>Disk</td>\n<td>500G</td>\n</tr>\n<tr>\n<td>OS</td>\n<td>CentOS release 6.5 (Final)</td>\n</tr>\n</tbody></table>\n<h4 id=\"框架参数\"><a href=\"#框架参数\" class=\"headerlink\" title=\"框架参数\"></a>框架参数</h4><table>\n<thead>\n<tr>\n<th>参数项</th>\n<th>Storm 配置</th>\n<th>Flink 配置</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Version</td>\n<td>Storm 1.1.0-mt002</td>\n<td>Flink 1.3.0</td>\n</tr>\n<tr>\n<td>Master Memory</td>\n<td>2600M</td>\n<td>2600M</td>\n</tr>\n<tr>\n<td>Slave Memory</td>\n<td>1600M * 16</td>\n<td>12800M * 2</td>\n</tr>\n<tr>\n<td>Parallelism</td>\n<td>2 supervisor<br>16 worker</td>\n<td>2 Task Manager<br>16 Task slots</td>\n</tr>\n</tbody></table>\n<h4 id=\"测试内容\"><a href=\"#测试内容\" class=\"headerlink\" title=\"测试内容\"></a>测试内容</h4><h5 id=\"场景一：“输入-输出”简单处理\"><a href=\"#场景一：“输入-输出”简单处理\" class=\"headerlink\" title=\"场景一：“输入-输出”简单处理\"></a>场景一：“输入-输出”简单处理</h5><p>通过对“输入-输出”这样简单处理逻辑场景的测试，尽可能减少其它因素的干扰，反映两个框架本身的性能。 同时测算框架处理能力的极限，处理更加复杂的逻辑的性能不会比纯粹“输入-输出”更高。</p>\n<p><img src=\"http://assets.msyy233.com/20191230/163410611.png!blog\" alt=\"Identity\"></p>\n<p>主要模拟“输入-输出”简单处理场景，反映两个框架<strong>本身的性能</strong>：</p>\n<ul>\n<li>输入数据为“msgId, eventTime”，其中 eventTime 视为数据生成时间。单条输入数据约 20 B。</li>\n<li>进入作业处理流程时记录 inTime，作业处理完成后（准备输出时）记录 outTime。</li>\n<li>作业从 Kafka Topic Data 中读取数据后，在字符串末尾追加时间戳，然后直接输出到 Kafka。</li>\n<li>输出数据为“msgId, eventTime, inTime, outTime”。单条输出数据约 50 B。</li>\n</ul>\n<p><img src=\"http://assets.msyy233.com/20191230/1640528f2.png!blog\" alt=\"Identity\"><br><img src=\"http://assets.msyy233.com/20200102/104213fef.png!blog\" alt=\"Identity\"><br><strong>此场景 <span style=\"color:red\">Flink吞吐约为Storm的 3-5 倍、满吞吐时Flink的延迟约为Storm的一半。</span></strong></p>\n<h5 id=\"场景二：用户作业耗时较长\"><a href=\"#场景二：用户作业耗时较长\" class=\"headerlink\" title=\"场景二：用户作业耗时较长\"></a>场景二：用户作业耗时较长</h5><p>如果用户的处理逻辑较为复杂，或是访问了数据库等外部组件，其执行时间会增大，作业的性能会受到影响。因此，我们测试了用户作业耗时较长的场景下两个框架的调度性能。  </p>\n<p><img src=\"http://assets.msyy233.com/20191230/1634548a8.png!blog\" alt=\"Sleep\"></p>\n<p>主要模拟用户作业耗时较长的场景，反映<strong>复杂用户逻辑对框架差异的削弱</strong>，比较两个框架的<strong>调度性能</strong>：</p>\n<ul>\n<li>输入数据和输出数据均与之前场景一相同。</li>\n<li>读入数据后，等待一定时长（1 ms）后在字符串末尾追加时间戳后输出</li>\n</ul>\n<p><img src=\"http://assets.msyy233.com/20200102/104409cee.png!blog\" alt=\"Sleep\"><br><img src=\"http://assets.msyy233.com/20200102/104431b75.png!blog\" alt=\"Sleep\"><br><strong>此场景 <span style=\"color:red\">两个框架的吞吐能力基本一致，Sleep 1 毫秒时，Flink的延迟仍低于Storm。</span></strong></p>\n<h5 id=\"场景三：窗口统计场景\"><a href=\"#场景三：窗口统计场景\" class=\"headerlink\" title=\"场景三：窗口统计场景\"></a>场景三：窗口统计场景</h5><p>实时计算中常有对时间窗口或计数窗口进行统计的需求，例如一天中每五分钟的访问量，每 100 个订单中有多少个使用了优惠等。Flink 在窗口支持上的功能比 Storm 更加强大，API 更加完善，但是我们同时也想了解在窗口统计这个常用场景下两个框架的性能。</p>\n<p><img src=\"http://assets.msyy233.com/20191230/163521e8b.png!blog\" alt=\"Windowed Word Count\"></p>\n<p>主要模拟窗口统计场景，反映两个框架在进行<strong>窗口统计时性能</strong>的差异。</p>\n<ul>\n<li>输入为 JSON 格式，包含 msgId、eventTime 和一个由若干单词组成的句子，单词之间由空格分隔。单条输入数据约 150 B。</li>\n<li>读入数据后解析 JSON，然后将句子分割为相应单词，带 eventTime 和 inTime 时间戳发给 CountWindow 进行单词计数，同时记录一个窗口中最大最小的 eventTime 和 inTime，最后带 outTime 时间戳输出到 Kafka 相应的 Topic。</li>\n<li>Spout/Source 及 OutputBolt/Output/Sink 并发度恒为 1，增大并发度时仅增大 JSONParser、CountWindow 的并发度。</li>\n<li>由于 Storm 对 window 的支持较弱，CountWindow 使用一个 HashMap 手动实现，Flink 用了原生的 CountWindow 和相应的 Reduce 函数。</li>\n</ul>\n<p><img src=\"http://assets.msyy233.com/20200102/104924460.png!blog\" alt=\"Windowed Word Count\"><br><img src=\"http://assets.msyy233.com/20200102/104945f1b.png!blog\" alt=\"Windowed Word Count\"><br><strong>此场景 <span style=\"color:red\">Flink吞吐依然为Storm的3倍以上，当QPS逐渐增大的时候，Flink在延迟上的优势开始体现出来。</span></strong></p>\n<h5 id=\"精确计算场景\"><a href=\"#精确计算场景\" class=\"headerlink\" title=\"精确计算场景\"></a>精确计算场景</h5><p>Storm 仅能保证“至多一次” (At Most Once) 和“至少一次” (At Least Once) 的消息投递语义，即可能存在重复发送的情况。有很多业务场景对数据的精确性要求较高，希望消息投递不重不漏。Flink 支持“恰好一次” (Exactly Once) 的语义，但是在限定的资源条件下，更加严格的精确度要求可能带来更高的代价，从而影响性能。因此，我们测试了在不同消息投递语义下两个框架的性能，希望为精确计算场景的资源规划提供数据参考。</p>\n<p>使用与场景三相同测试方法进行了精确计算场景的测试，用来评测Flink<strong>恰好一次投递的性能</strong>。</p>\n<p><img src=\"http://assets.msyy233.com/20200102/1054278bf.png!blog\" alt=\"Exactly Once\"><br><img src=\"http://assets.msyy233.com/20200102/10564328a.png!blog\" alt=\"Exactly Once\"></p>\n<p><strong>此场景 <span style=\"color:red\">Flink的Exactly Once吞吐较At Least Once而言下降了6.3%，Exactly Once 的延迟中位数曲线与 At Least Once 基本贴合，在延迟上性能没有太大差异</span></strong></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>绝大部分情况、几乎不用犹豫该使用哪个框架、除非涉及到老系统迁移、否则<strong>Flink总会是最优选</strong>、</p>\n<h2 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h2><p>存储部分主要是Hbase&amp;Hadoop和Elasticsearch之间做些选择、由于日志肯定是需要多维度搜索的、否则集中管理的意义不大、Elasticsearch在达到准实时搜索的同时也支持比较高的数据量、Hbase&amp;Hadoop虽然也可以加入Solr组件来支持、但是毕竟不是非常合适、而且要维护一套大数据集群成本也很高、这里就不介绍了、只对Elasticsearch进行一些介绍、</p>\n<h1 id=\"分布式日志平台\"><a href=\"#分布式日志平台\" class=\"headerlink\" title=\"分布式日志平台\"></a>分布式日志平台</h1><h2 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h2><p>简单的日志查询没有任何意义，日志信息需要上下文关联，做到上下文关联的方式可以借助多种方案。例如：通过分布式链路追踪工具将追踪ID输出到日志、通过改造日志实现关系查询的串联（也许需要一个强大的引擎）。</p>\n<h2 id=\"处理\"><a href=\"#处理\" class=\"headerlink\" title=\"处理\"></a>处理</h2><p>对于一些数据指标的运算吧，简单说说就是链路明细、链路概览、链路索引、异常统计等等吧。</p>\n<h2 id=\"告警\"><a href=\"#告警\" class=\"headerlink\" title=\"告警\"></a>告警</h2><p>实施处理的数据就可以实时告警、基础功能不再赘述。</p>\n<h1 id=\"落地的技术考量\"><a href=\"#落地的技术考量\" class=\"headerlink\" title=\"落地的技术考量\"></a>落地的技术考量</h1><h2 id=\"Filebeat-1\"><a href=\"#Filebeat-1\" class=\"headerlink\" title=\"Filebeat\"></a>Filebeat</h2><p>Fluentd和Filebeat都足够优秀、让人难以抉择、但是最终我决定选用二者中选择Filebeat、主要有以下原因：</p>\n<ol>\n<li>同为开源产品、但从Github Star发展势头来看、Filebeat虽然晚两年但是发展势头是慢慢赶超Fluentd的、</li>\n<li>Filebeat与Elastic家族其他产品具有更好的集成性、例如：我需要保证审计日志百分百不丢失、就可以使用Filebeat直接输出的ES、Fluentd虽然也支持输出但并不支持背压敏感协议、</li>\n<li>相比基于ruby的Fluentd、golang技术栈的Filebeat对使用容器化的公司更友好、更具可定制性、</li>\n<li>未来官方会开放一个集中管理的API、这对大规模的集群管理很有帮助、而Fluentd并没有找到相关的资料、</li>\n<li>网络搜索结果Filebeat的资料数量是Fluentd的三倍、</li>\n<li>除了Filebeat以外、官方还扩展了很多其他beats、这对以后可能存在的功能扩展做了预留、</li>\n</ol>\n<h2 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h2><p>在满足要求的情况下Kafka的性能几乎是RocketMQ的1.5倍、我想不出还有什么消息中间件的性能可以超过Kafka、又或者说比Kakfa更适合做日志管道、</p>\n<h2 id=\"Flink\"><a href=\"#Flink\" class=\"headerlink\" title=\"Flink\"></a>Flink</h2><p>我不明白经过上面的技术栈对比、还有什么不选择Flink的理由、Exactly Once支持、有状态、完善的窗口支持同时又保证了高性能、高吞吐量难道不香吗？</p>\n<h2 id=\"Elasticsearch\"><a href=\"#Elasticsearch\" class=\"headerlink\" title=\"Elasticsearch\"></a>Elasticsearch</h2><p>如果你只是需要一套日志存储系统、毫无疑问类似Hadoop这样的大数据系列是更好的选择、但是如果你需要的是一套日志检索系统那么选择ES吧、没有理由、因为它就是最优的选择、</p>\n<h2 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h2><p>我在是否使用Kibana考虑了很久、毕竟整个技术选型大部分是Elastic家族的产品、尤其是比较重要的存储和收集、无论如何他们对同为Elastic家族的Kibana支持是最好的、但是Kibana在个性化的一些查询中可能会显得力不从心、这里可以参考上个章节的分布式日志平台想关功能、不仅仅如此、Kibana在对多租户的支持方向也非常不友好、而对Kibana进行二次开发的学习成本太高、因此展示这边可能使用自研更合适、而我之所以选用Vue是因为我们德邦快递公司前端技术架构使用了它、</p>\n<h1 id=\"最终的实施步骤\"><a href=\"#最终的实施步骤\" class=\"headerlink\" title=\"最终的实施步骤\"></a>最终的实施步骤</h1><p>实施步骤省略。这里引出一个问题，经过艰苦努力，终于完成了基本的日志查询问题，可是如此海量的日志所需要的硬件资源也是个高昂的费用，实现上述基础功能可以直接找供应商，也许落地成本更低。如何才能让数据发挥应有的价值？是不是只有应用系统才有日志？也许可以思考一下“数字化运营平台”。</p>\n<hr>\n<p><strong>参考资料：</strong><br><a href=\"https://tech.meituan.com/2017/11/17/flink-benchmark.html\">流计算框架 Flink 与 Storm 的性能对比</a><br><a href=\"https://zhuanlan.zhihu.com/p/79579389\">Kafka史上最详细原理总结</a></p>\n","categories":["log"],"tags":["logstash","elk","kibana","filebeat","kafka","elasticsearch","flume","fluentd","fluent-bit","efk","es","日志平台","日志分析","实时计算","storm","flink"]}]